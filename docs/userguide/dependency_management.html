<html>
 <head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <title>第五十章. 依赖管理 - Chapter&nbsp;50.&nbsp;Dependency Management</title>
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="base.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="docs.css">
  <link xmlns:xslthl="http://xslthl.sf.net" type="text/css" rel="stylesheet" href="userguide.css">
  <meta content="DocBook XSL Stylesheets V1.75.2" name="generator">
  <link rel="home" href="userguide.html" title="Gradle 用户指南">
  <link rel="up" href="userguide.html" title="Gradle 用户指南">
  <link rel="prev" href="buildDashboard_plugin.html" title="第四十九章. 构建仪表盘插件">
  <link rel="next" href="artifact_management.html" title="第五十一章. 发布工件">
 </head>
 <body>
  <div class="navheader">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="buildDashboard_plugin.html" title="第四十九章. 构建仪表盘插件">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="artifact_management.html" title="第五十一章. 发布工件">下一章</a>
    </div>
   </div>
  </div>
  <div class="chapter">
   <div class="titlepage">
    <div>
     <div>
      <h1 xmlns:xslthl="http://xslthl.sf.net"><a name="dependency_management"></a>第五十章. 依赖管理</h1>
      <h3 xmlns:xslthl="http://xslthl.sf.net"><a name="dependency_management"></a>Chapter&nbsp;50.&nbsp;Dependency Management</h3>
     </div>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:Introduction"></a>50.1.导言</h2>
       <h4 class="title"><a name="sec:Introduction"></a>50.1.&nbsp;Introduction</h4>
      </div>
     </div>
    </div>
    <p>依赖关系管理是每个构建的一个关键特性，Gradle的重点在于提供易于理解且与各种方法兼容的一流的依赖管理。 如果您熟悉Maven或Ivy所使用的方法，那么你会很高兴知道Gradle完全兼容这两种方法，此外，它还具有足够的灵活性以支持完全自定义的方法。 <br>Dependency management is a critical feature of every build, and Gradle has placed an emphasis on offering first-class dependency management that is both easy-to-understand and compatible with a wide variety of approaches. If you are familiar with the approach used by either Maven or Ivy you will be delighted to learn that Gradle is fully compatible with both approaches in addition to being flexible enough to support fully-customized approaches.</p>
    <p>以下是 Gradle 支持的依赖管理的主要亮点：<br>Here are the major highlights of Gradle's support for dependency management:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p><span class="emphasis"><em>依赖管理传递</em></span>：Gradle 使你可以完全控制项目的依赖树。 </p><p><span class="emphasis"><em>Transitive dependency management</em></span>: Gradle gives you full control of your project's dependency tree. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>对非管理依赖的支持</em></span>：如果你的依赖只是版本控制下或共享驱动器中的文件，Gradle 也提供了强大的功能来支持这种情况。 </p><p><span class="emphasis"><em>Support for non-managed dependencies</em></span>: If your dependencies are simply files in version control or a shared drive, Gradle provides powerful functionality to support this. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>对自定义依赖定义的支持</em></span>：Gradle 的模块依赖使你能够描述构建脚本中的依赖层次结构。 </p><p><span class="emphasis"><em>Support for custom dependency definitions.</em></span>: Gradle's Module Dependencies give you the ability to describe the dependency hierarchy in the build script. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>完全可自定义的依赖解析方法</em></span>：Gradle 使你能够自定义使依赖替换变得简单的解析规则。 </p><p><span class="emphasis"><em>A fully customizable approach to Dependency Resolution</em></span>: Gradle provides you with the ability to customize resolution rules making dependency substitution easy. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>完全兼容 Maven 和 Ivy </em></span>：如果你已经在 Maven POM 文件或 Ivy 文件中定义了依赖，Gradle 有提供一系列常用的构建工具来进行无缝集成。 </p><p><span class="emphasis"><em>Full Compatibility with Maven and Ivy</em></span>: If you have defined dependencies in a Maven POM or an Ivy file, Gradle provide seamless integration with a range of popular build tools. </p></li>
      <li class="listitem"><p><span class="emphasis"><em>与现有依赖管理基础结构的集成</em></span>：Gradle兼容Maven和Ivy仓库。 如果你是使用Archiva， Nexus或Artifactory，Gradle与所有仓库格式100%兼容。 </p><p><span class="emphasis"><em>Integration with existing dependency management infrastructure</em></span>: Gradle is compatible with both Maven and Ivy repositories. If you use Archiva, Nexus, or Artifactory, Gradle is 100% compatible with all repository formats. </p></li>
     </ul>
    </div>
    <p> 由于成千上万相互依赖的开源组件各有一系列版本和不兼容性，依赖管理常常导致问题的复杂性增加。 当一个构建的依赖树变得笨拙时，你的构建工具不应强制你对依赖管理采取单一、不灵活的方法。 一个正确的构建系统必须设计得灵活，而Gradle可以处理任何情况。 <br>With hundreds of thousands of interdependent open source components each with a range of versions and incompatibilities, dependency management has a habit of causing problems as builds grow in complexity. When a build's dependency tree becomes unwieldy, your build tool shouldn't force you to adopt a single, inflexible approach to dependency management. A proper build system has to be designed to be flexible, and Gradle can handle any situation.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:dependency_management_and_migrations"></a>50.1.1. 迁移的灵活依赖管理</h3>
        <h5 class="title"><a name="sub:dependency_management_and_migrations"></a>50.1.1.&nbsp;Flexible dependency management for migrations</h5>
       </div>
      </div>
     </div>
     <p> 在从一个构建系统迁移到另一个构建系统的过程当中，对于依赖管理而方，可能特别具有挑战性。 如果你要从Ant或Maven之类的工具迁移到Gradle，那么可能会面临一些困难的情况。 例如一个常见的模式是Ant项目，其中包含了存储在文件系统中的无版本jar文件。 其他构建系统需要在迁移之前批量替换此方法。而使用Gradle，你可以让新构建调整为任何现有的依赖源或依赖元数据。这使得增量迁移到Gradle的难度比其他的规范方案要容易得多。 在大多数大型项目上，构建迁移以及对开发流程的任何更改都是增量进行的，因为大多数组织都无法停止所有的一切，并迁移到一个构建工具的依赖管理概念中。 <br>Dependency management can be particularly challenging during a migration from one build system to another. If you are migrating from a tool like Ant or Maven to Gradle, you may be faced with some difficult situations. For example, one common pattern is an Ant project with version-less jar files stored in the filesystem. Other build systems require a wholesale replacement of this approach before migrating. With Gradle, you can adapt your new build to any existing source of dependencies or dependency metadata. This makes incremental migration to Gradle much easier than the alternative. On most large projects, build migrations and any change to development process is incremental because most organizations can't afford to stop everything and migrate to a build tool's idea of dependency management.</p>
     <p>即使你的项目正在使用自定义的依赖管理系统，或或是一些像Eclipse.classpath文件作为依赖管理的主数据，也很容易编写Gradle插件在Gradle中使用此数据。 出于迁移目的，这是Gradle中的常见技术。（但是，如果你已经迁移，那么可以从.classpath文件中移出并直接使用Gradle的依赖管理功能可能是个好主意。） <br>Even if your project is using a custom dependency management system or something like an Eclipse .classpath file as master data for dependency management, it is very easy to write a Gradle plugin to use this data in Gradle. For migration purposes this is a common technique with Gradle. (But, once you've migrated, it might be a good idea to move away from a .classpath file and use Gradle's dependency management features directly.)</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:dependency_management_and_java"></a>50.1.2. 依赖管理和 Java</h3>
        <h5 class="title"><a name="sub:dependency_management_and_java"></a>50.1.2.&nbsp;Dependency management and Java</h5>
       </div>
      </div>
     </div>
     <p>具有讽刺意味的是，以丰富的开源组件库著称的语言，Java竟然没有库或者版本的概念。在Java中，没有标准的方法来告知JVM你正在使用Hibernate V3.0.5，也没有标准的方法来表示 <code class="literal">foo-1.0.jar</code> 依赖于 <code class="literal">bar-2.0.jar</code>。 这导致了外部的解决方案通常都会基于构建工具。 目前最受欢迎的解决方案是Maven和Ivy。 Maven提供了完整的构建系统，而Ivy则只着眼于依赖管理。 <br>It is ironic that in a language known for its rich library of open source components that Java has no concept of libraries or versions. In Java, there is no standard way to tell the JVM that you are using version 3.0.5 of Hibernate, and there is no standard way to say that <code class="literal">foo-1.0.jar</code> depends on <code class="literal">bar-2.0.jar</code>. This has led to external solutions often based on build tools. The most popular ones at the moment are Maven and Ivy. While Maven provides a complete build system, Ivy focuses solely on dependency management.</p>
     <p>这两种工具都依赖于描述符XML文件，这些文件包含有关特定jar的依赖信息。 它们还使用仓库，在这些仓库中，实际的jar与它们的描述符文件放在一起；并且这两者都以一种形式或其他形式提供了jar版本冲突的解决方案。它们都成为解决依赖冲突的标准，而Gradle对于依赖管理从一开始在底层上使用的是Ivy。Gradle取代了对Ivy的直接依赖，采用了本地Gradle语解决引擎，该引擎支持一系列依赖解决方案的方法，包括POM和Ivy描述符文件。 <br>Both tools rely on descriptor XML files, which contain information about the dependencies of a particular jar. Both also use repositories where the actual jars are placed together with their descriptor files, and both offer resolution for conflicting jar versions in one form or the other. Both have emerged as standards for solving dependency conflicts, and while Gradle originally used Ivy under the hood for its dependency management. Gradle has replaced this direct dependency on Ivy with a native Gradle dependency resolution engine which supports a range of approaches to dependency resolution including both POM and Ivy descriptor files.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependency_management_overview"></a>50.2. 依赖管理最佳实践</h2>
       <h4 class="title"><a name="sec:dependency_management_overview"></a>50.2.&nbsp;Dependency Management Best Practices</h4>
      </div>
     </div>
    </div>
    <p>由于Gradle在依赖管理方面有强烈的主张，该工具提供了两个选项让你从中选择：遵循推荐的最佳实践，或支持你可以想到的任何类型的模式。 本节概述Gradle项目建议的用于管理依赖的最佳实践。 <br>While Gradle has strong opinions on dependency management, the tool gives you a choice between two options: follow recommended best practices or support any kind of pattern you can think of. This section outlines the Gradle project's recommended best practices for managing dependencies.</p>
    <p>无论哪种语言，适当的依赖管理对于每个项目都很重要。从一个由Java编写的依赖数百个开源库的复杂企业应用，到依赖少数几个库的最简单的Clojure应用，依赖管理的方法大不相同，并且可能取决于目标技术、应用程序部署的方法以及项目的性质。多上项目捆绑为可复用的库，比起企业应用集成到更大规模的软件和基础结构系统中，可能有不同的需求。尽管需求的差异很大，Gradle项目建议所有项目都遵循这组核心规则： <br>No matter what the language, proper dependency management is important for every project. From a complex enterprise application written in Java depending on hundreds of open source libraries to the simplest Clojure application depending on a handful of libraries, approaches to dependency management vary widely and can depend on the target technology, the method of application deployment, and the nature of the project. Projects bundled as reusable libraries may have different requirements than enterprise applications integrated into much larger systems of software and infrastructure. Despite this wide variation of requirements, the Gradle project recommends that all projects follow this set of core rules:</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:versioning_the_jar_name"></a>50.2.1. 在文件名中包含版本号（版本化 jar ）</h3>
        <h5 class="title"><a name="sub:versioning_the_jar_name"></a>50.2.1.&nbsp;Put the Version in the Filename (Version the jar)</h5>
       </div>
      </div>
     </div>
     <p>在文件名中库的版本必须是容易辨认的。虽然jar的版本通常在Manifest文件中，但当你要检查项目时它并不显而易见。如果有人让你看20个jar文件，你更愿意哪一种?名字像 <code class="filename">commons-beanutils-1.3.jar</code> 的文件集还是名字像 <code class="filename">spring.jar</code>的文件集?如果依赖的文件名称带有版本号，那么将更容易快速确定依赖的版本。 <br>The version of a library must be easy to recognize in the filename. While the version of a jar is usually in the Manifest file, it isn't readily apparent when you are inspecting a project. If someone asks you to look at a collection of 20 jar files, which would you prefer? A collection of files with names like <code class="filename">commons-beanutils-1.3.jar</code> or a collection of files with names like <code class="filename">spring.jar</code>? If dependencies have file names with version numbers it is much easier to quickly identify the versions of your dependencies.</p>
     <p>如果版本不清楚，你可能会引入一些很难找以的微妙错误。例如可能有一个项目使用 Hibernate 2.5，想一下一个开发者决定在她的机器上安装 3.0.5 的版本，以修复一个关键的安全 bug，但她忘记通知其他团队这个变化。她可能成功地解决了这个安全 bug，但她也可能引入一些 bug 到代码库中，如项目用到了 Hibernate 现在弃用的功能。一周后，在集成的机器上可能会有一个异常，而这个异常无法在任何人的机器上复现。然后多个开发者花了数天的时间去查这个问题，最终才意识到，如果他们知道 Hibernate 已经从 2.5 升级到 3.0.5，这个错误会很容易发现。 <br>If versions are unclear you can introduce subtle bugs which are very hard to find. For example there might be a project which uses Hibernate 2.5. Think about a developer who decides to install version 3.0.5 of Hibernate on her machine to fix a critical security bug but forgets to notify others in the team of this change. She may address the security bug successfully, but she also may have introduced subtle bugs into a codebase that was using a now-deprecated feature from Hibernate. Weeks later there is an exception on the integration machine which can't be reproduced on anyone's machine. Multiple developers then spend days on this issue only finally realising that the error would have easy to uncover if they knew that Hibernate had been upgraded from 2.5 to 3.0.5.</p>
     <p>在 jar 名称中的版本增强了项目的表现性，并使其更易于维护。这种做法也减少了发生错误的可能。 <br>Versions in jar names increase the expressiveness of your project and make them easier to maintain. This practice also reduces the potential for error.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:transitive_dependency_management"></a>50.2.2. 管理传递依赖</h3>
        <h5 class="title"><a name="sub:transitive_dependency_management"></a>50.2.2.&nbsp;Manage transitive dependencies</h5>
       </div>
      </div>
     </div>
     <p>传递依赖管理是一种使你的项目依赖于一些库，而这些库又依赖于其他库技术。这种传递依赖的递归模式导致的结果说，在依赖树中，会包含项目的第一级依赖，第二级依赖，等等。如果你不按层级树的第一级和二级依赖对你的依赖建模，那么就会很容易失去对组合的非结构化依赖的控制。请考虑Gradle项目本身，而Gradle仅具有几个直接的第一级依赖，当编译Gradle时，在它的类路径上会需要超过一百个依赖。在规模更大的范围内，使用Spring、Hibernate和其他库，以及成百上千的内部项目的企业项目，可能有非常大的依赖树。 <br>Transitive dependency management is a technique that enables your project to depend on libraries which, in turn, depend on other libraries. This recursive pattern of transitive dependencies results in a tree of dependencies including your project's first-level dependencies, second-level dependencies, and so on. If you don't model your dependencies as a hierarchical tree of first-level and second-level dependencies it is very easy to quickly lose control over an assembled mess of unstructured dependencies. Consider the Gradle project itself, while Gradle only has a few direct, first-level dependencies, when Gradle is compiled it needs more that one hundred dependencies on the classpath. On a far larger scale, Enterprise projects using Spring, Hibernate, and other libraries, alongside hundreds or thousands of internal projects can have very large dependency trees.</p>
     <p>当这些大的依赖树需要更改时，你通常需要解决某些依赖的版本冲突。比如说某个开源代码库需要一个版本的日志记录库，而另一个需要另一个版本。 Gradle和其他构建工具都能够解决这种依赖树并解决冲突，但不同的是，Gradle使你可以控制传递依赖冲突解决。 <br>When these large dependency trees need to change, you'll often have to solve some dependency version conflicts. Say one open source library needs one version of a logging library and a another uses an alternative version. Gradle and other build tools all have the ability to solve this dependency tree and resolve conflicts, but what differentiates Gradle is the control it gives you over transitive dependencies and conflict resolution.</p>
     <p>虽然你可以尝试手动管理此问题，但你很快就会发现此方法不能扩展。 如果你要去掉第一级依赖，你确实不能确定还有其他哪些 jar 是你需要移除的。第一级依赖的依赖本身也可能是第一级依赖，或者是另一个第一级依赖的传递依赖。 如果你想自己管理传递依赖，最终的结局是你的构建会变得很脆弱：没人敢更改你的依赖，因为破坏构建的风险太高了。 项目类路径将变得完全混乱，如果发生类路径问题，那简直就是人间地狱。 <br>While you could try to manage this problem manually, you will quickly find that this approach doesn't scale. If you want to get rid of a first level dependency you really can't be sure which other jars you should remove. A dependency of a first level dependency might also be a first level dependency itself, or it might be a transitive dependency of yet another first level dependency. If you try to manage transitive dependencies yourself, the end of the story is that your build becomes brittle: no one dares to change your dependencies because the risk of breaking the build is too high. The project classpath becomes a complete mess, and, if a classpath problem arises, hell on earth invites you for a ride.</p>
     <div class="note">
      <span class="emphasis"><em>注：</em><br><em>NOTE:</em></span>在一个项目中，我们在类路径中找到了一个神秘的 LDAP 相关的 jar。 没有代码引用此JAR，并且该 jar 包也没有与项目有任何连接。 没人知道该 jar 的用途，直到它从构建中去除，并且应用程序在尝试向 LDAP 进行认证时遇到了严重的性能问题。 这个神秘的 jar 是一个必需传递的第四级依赖，很容易被忽略，因为没有人会费心去使用受管的传递依赖。 
     </div>
     <p>Gradle为你提供了不同的表达第一级和传递依赖的方法。 通过Gradle，你可以混合使用和适配一些方法；例如，你可以在 SCM 中存储 jar而不需要 XML描述符文件，并且仍然使用传递依赖管理。 <br>Gradle offers you different ways to express first-level and transitive dependencies. With Gradle you can mix and match approaches; for example, you could store your jars in an SCM without XML descriptor files and still use transitive dependency management.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:version_conflicts"></a>50.2.3. 解决版本冲突</h3>
        <h5 class="title"><a name="sub:version_conflicts"></a>50.2.3.&nbsp;Resolve version conflicts</h5>
       </div>
      </div>
     </div>
     <p> 相同的jar的冲突版本应该被检测到，并且要么解决要么抛出异常。 如果不使用传递依赖管理，版本冲突没被检测到，那以在类路径中的无法预测的顺序将决定最终使用哪个版本的依赖。在有许多开发者更改依赖的大型项目上，成功的构建将会少之又少，因为依赖的顺序可能直接影响构建是否成功（或者在生产中是否出现错误）。 <br>Conflicting versions of the same jar should be detected and either resolved or cause an exception. If you don't use transitive dependency management, version conflicts are undetected and the often accidental order of the classpath will determine what version of a dependency will win. On a large project with many developers changing dependencies, successful builds will be few and far between as the order of dependencies may directly affect whether a build succeeds or fails (or whether a bug appears or disappears in production).</p>
     <p>如果你还没有处理过在类路径中 jar 包版本冲突的麻烦，这里有一个小趣闻等着你。在一个有30个子模块的大型项目中，向子项目添加的一个依赖改变了类路径的顺序，Spring 2.5与老的2.4版本 顺序被调换了。虽然可以继续构建，开发者会开始注意到在生产中出现了各种令人惊讶（和惊人可怕）的bug。然而，更糟糕的是，无意降低版本的Spring向系统引入了几个安全缺陷，现在需要整个组织进行全面的安全审计。 <br>If you haven't had to deal with the curse of conflicting versions of jars on a classpath, here is a small anecdote of the fun that awaits you. In a large project with 30 submodules, adding a dependency to a subproject changed the order of a classpath, swapping Spring 2.5 for an older 2.4 version. While the build continued to work, developers were starting to notice all sorts of surprising (and surprisingly awful) bugs in production. Worse yet, this unintentional downgrade of Spring introduced several security vulnerabilities into the system, which now required a full security audit throughout the organization.</p>
     <p>简而言之，版本冲突是很不好的，你应该管理您的传递依赖以避免版本冲突。你可能还希望了解使用冲突版本的位置，并在整个组织中统一依赖的指定版本。有了类似于Gradle的良好冲突报告工具，这些信息可 用于与整个组织进行通信，并在单个版本上实现标准化。<span class="emphasis"><em>如果你觉得你不会发生版本冲突，那就再想想。</em></span>不同的第一级依赖，依赖于其他依赖的不同重叠范围的版本非常常见，并且JVM还不能提供简单的方法，使是能在类路径中让相同的 jar 包可以有不同的版本（请参阅 《<a class="xref" href="dependency_management.html#sub:dependency_management_and_java">第50.1.2节，“依赖管理与Java”</a>）。 <br>In short, version conflicts are bad, and you should manage your transitive dependencies to avoid them. You might also want to learn where conflicting versions are used and consolidate on a particular version of a dependency across your organization. With a good conflict reporting tool like Gradle, that information can be used to communicate with the entire organization and standardize on a single version. <span class="emphasis"><em>If you think version conflicts don't happen to you, think again.</em></span> It is very common for different first-level dependencies to rely on a range of different overlapping versions for other dependencies, and the JVM doesn't yet offer an easy way to have different versions of the same jar in the classpath (see <a class="xref" href="dependency_management.html#sub:dependency_management_and_java">Section&nbsp;50.1.2, “Dependency management and Java”</a>).</p>
     <p>Gradle 提供了以下的冲突解决策略：<br>Gradle offers the following conflict resolution strategies:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"><span class="emphasis"><em>Newest</em></span>：将使用最新版本的依赖。 这是Gradle的默认策略，只要版本都能向后兼容，通常是合适的选择。 <br><span class="emphasis"><em>Newest</em></span>: The newest version of the dependency is used. This is Gradle's default strategy, and is often an appropriate choice as long as versions are backwards-compatible.</li>
       <li class="listitem"><span class="emphasis"><em>Fail</em></span>：版本冲突导致构建失败。这种策略强制在构建脚本中显示地解决所有版本冲突。有关如何显式选择特定版本的详细信息，请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>。 <br><span class="emphasis"><em>Fail</em></span>: A version conflict results in a build failure. This strategy enforces that all version conflicts are resolved explicitly in the build script. See <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for details on how to explicitly choose a particular version.</li>
      </ul>
     </div>
     <p>虽然上面介绍的策略通常足够解决大部分的冲突，但是 Gradle 也提供了更细粒度的机制来解决版本冲突：<br>While the strategies introduced above are usually enough to solve most conflicts, Gradle provides more fine-grained mechanisms to resolve version conflicts:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"> 将第一级依赖配置为<span class="emphasis"><em>强制</em></span>。如果冲突中的依赖已经是第一级依赖，那么这一方法会很有用。请参阅 <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>中的示例。 <br>Configuring a first level dependency as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is already a first level dependency. See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>.</li>
       <li class="listitem"> 将任何依赖（传递依赖或非传递依赖）配置为<span class="emphasis"><em>强制</em></span>。 如果冲突中的依赖是传递依赖，那么这种方法会很有用。 它还可用于强制第一级依赖的版本。请参阅 <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>中的示例。<br>Configuring any dependency (transitive or not) as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is a transitive dependency. It also can be used to force versions of first level dependencies. See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a></li>
       <li class="listitem"> 依赖解析规则是一个在 Gradle 1.4 引进的<a class="link" href="feature_lifecycle.html">实验性</a>功能，让你可以对特定的依赖选择的版本进行细粒度控制。 <br>Dependency resolve rules are an <a class="link" href="feature_lifecycle.html">incubating</a> feature introduced in Gradle 1.4 which give you fine-grained control over the version selected for a particular dependency.</li>
      </ul>
     </div>
     <p>为了解决版本冲突的问题，带有依赖关系图的报告也是很有帮助的。这种报告是依赖管理的另一个功能。<br>To deal with problems due to version conflicts, reports with dependency graphs are also very helpful. Such reports are another feature of dependency management.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:dynamic_versions_and_changing_modules"></a>50.2.4. 使用动态版本和变化模块</h3>
        <h5 class="title"><a name="sub:dynamic_versions_and_changing_modules"></a>50.2.4.&nbsp;Use Dynamic Versions and Changing Modules</h5>
       </div>
      </div>
     </div>
     <p>当您想要使用特定依赖的最新版本或某个版本范围内的最新版本时，有许多情况。这可能是开发期中需要，或者可能你正在开发一个库，它被设计为使用某个范围内的依赖版本。你可以通过使用<span class="emphasis"><em>动态版本</em></span>很容易地依赖这些不断变化的依赖。动态版本可以是一个版本范围（例如<code class="literal">2.+</code>），也可以是最新版本的占位符（比如<code class="literal">latest.integration</code>）。 <br>There are many situation when you want to use the latest version of a particular dependency, or the latest in a range of versions. This can be a requirement during development, or you may be developing a library that is designed to work with a range of dependency versions. You can easily depend on these constantly changing dependencies by using a <span class="emphasis"><em>dynamic version</em></span>. A dynamic version can be either a version range (e.g. <code class="literal">2.+</code>) or it can be a placeholder for the latest version available (e.g. <code class="literal">latest.integration</code>).</p>
     <p>或者，有时你请求的模块可能会随着时间的推移而变化，即使是版本相同。这种<span class="emphasis"><em>变化模块</em></span>类型的一个例子是Maven的<code class="literal">SNAPSHOT</code>模块，它始终指向最新发布的工件。换句话说，一个标准的Maven快照是一个永远不会不变的模块，可以这样说，它是一个“变化模块”。 <br>Alternatively, sometimes the module you request can change over time, even for the same version. An example of this type of <span class="emphasis"><em>changing module</em></span> is a Maven <code class="literal">SNAPSHOT</code> module, which always points at the latest artifact published. In other words, a standard Maven snapshot is a module that never stands still so to speak, it is a "changing module".</p>
     <p><span class="emphasis"><em>动态版本</em></span> 和 <span class="emphasis"><em>变化模块</em></span> 之间的主要差别是，当你解析一个 <span class="emphasis"><em>动态版本</em></span>时，你会得到真实的、静态的版本作为模块名称。当你解析一个 <span class="emphasis"><em>变化模块</em></span>时，将使用你请求的版本来命名工件，但底层工件可能会随时间而变化。 <br>The main difference between a <span class="emphasis"><em>dynamic version</em></span> and a <span class="emphasis"><em>changing module</em></span> is that when you resolve a <span class="emphasis"><em>dynamic version</em></span>, you'll get the real, static version as the module name. When you resolve a <span class="emphasis"><em>changing module</em></span>, the artifacts are named using the version you requested, but the underlying artifacts may change over time.</p>
     <p>默认情况下，Grdale 对动态版本和变化模块的缓存时间是24小时。你可能使用<a class="link" href="dependency_management.html#sec:cache_command_line_options">命令行选项</a>重写默认的缓存模式。你可以通过 <code class="literal">resolution strategy</code> 修改你的构建的缓存到期时间（见<a class="xref" href="dependency_management.html#sec:controlling_caching">第 50.9.3 节，《调整控制依赖缓存》</a>）。 <br>By default, Gradle caches dynamic versions and changing modules for 24 hours. You can override the default cache modes using <a class="link" href="dependency_management.html#sec:cache_command_line_options">command line options</a>. You can change the cache expiry times in your build using the <code class="literal">resolution strategy</code> (see <a class="xref" href="dependency_management.html#sec:controlling_caching">Section&nbsp;50.9.3, “Fine-tuned control over dependency caching”</a>).</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sub:configurations"></a>50.3. 依赖配置</h2>
       <h4 class="title"><a name="sub:configurations"></a>50.3.&nbsp;Dependency configurations</h4>
      </div>
     </div>
    </div>
    <p>在Gradle中，依赖将被分组到配置。配置有一个名称和许多其他属性，并且可以相互扩展。许多Gradle插件会向项目添加了预定义的配置。例如，Java插件添加了一些配置来表示它需要的各种类路径。有关详细信息，请参阅 <a class="xref" href="java_plugin.html#sec:java_plugin_and_dependency_management">第23.5节，《依赖管理》</a> 。当然，你可以在此基础上添加自定义配置。有关自定义配置的用例很多。这是非常方便的，例如添加依赖时不需要再去构建或测试你的软件（比如，要随分发一起提供的其他JDBC驱动程序）。 <br>In Gradle dependencies are grouped into configurations. Configurations have a name, a number of other properties, and they can extend each other. Many Gradle plugin add pre-defined configurations to your project. The Java plugin, for example, adds some configurations to represent the various classpaths it needs. see <a class="xref" href="java_plugin.html#sec:java_plugin_and_dependency_management">Section&nbsp;23.5, “Dependency management”</a> for details. Of course you can add custom configurations on top of that. There are many use cases for custom configurations. This is very handy for example for adding dependencies not needed for building or testing your software (e.g. additional JDBC drivers to be shipped with your distribution).</p>
    <p> 项目的配置由 <code class="literal">configurations</code> 对象管理。你传给这个配置对象的闭包将通过它对应的 API 被应用。要了解有关此 API 的更多信息，请查看 <a class="ulink" href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" target="_top"><code class="classname">ConfigurationContainer</code></a>。 <br>A project's configurations are managed by a <code class="literal">configurations</code> object. The closure you pass to the configurations object is applied against its API. To learn more about this API have a look at <a class="ulink" href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" target="_top"><code class="classname">ConfigurationContainer</code></a>.</p>
    <p>如果要定义配置：<br>To define a configuration:</p>
    <div class="example">
     <a name="defineConfiguration"></a>
     <p class="title"><b>示例 50.1. 配置的定义 - Example&nbsp;50.1.&nbsp;Definition of a configuration</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">configurations {
    compile
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p>如果要访问配置：<br>To access a configuration:</p>
    <div class="example">
     <a name="defineConfiguration"></a>
     <p class="title"><b>示例 50.2. 访问配置 - Example&nbsp;50.2.&nbsp;Accessing a configuration</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">println configurations.compile.name
println configurations[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>].name</pre>
     </div>
    </div>
    <br class="example-break">
    <p>如果要配置一个配置：<br>To configure a configuration:</p>
    <div class="example">
     <a name="defineConfiguration"></a>
     <p class="title"><b>示例 50.3. 配置的配置 - Example&nbsp;50.3.&nbsp;Configuration of a configuration</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">configurations {
    compile {
        description = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile classpath'</span>
        transitive = true
    }
    runtime {
        extendsFrom compile
    }
}
configurations.compile {
    description = <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile classpath'</span>
}</pre>
     </div>
    </div>
    <br class="example-break">
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:how_to_declare_your_dependencies"></a>50.4. 如何声明依赖</h2>
       <h4 class="title"><a name="sec:how_to_declare_your_dependencies"></a>50.4.&nbsp;How to declare your dependencies</h4>
      </div>
     </div>
    </div>
    <p>你可以声明几种不同类型的依赖： <br>There are several different types of dependencies that you can declare:</p>
    <div xmlns:xslthl="http://xslthl.sf.net" class="table">
     <p class="title"><b>表 50.1. 依赖类型 - Table&nbsp;50.1.&nbsp;Dependency types</b></p>
     <div class="table-contents">
      <table id="N14C75">
       <thead>
        <tr> 
         <td>类型<br>Type</td> 
         <td>描述<br>Description</td> 
        </tr>
       </thead>
       <tbody>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:module_dependencies">外部模块依赖</a> <br><a class="link" href="dependency_management.html#sub:module_dependencies">External module dependency</a></td> 
         <td>对一些仓库中的外部模块的依赖。<br>A dependency on an external module in some repository.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:project_dependencies">项目依赖</a> <br><a class="link" href="dependency_management.html#sub:project_dependencies">Project dependency</a></td> 
         <td>对同一个构建中另一个项目的依赖。<br>A dependency on another project in the same build.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:file_dependencies">文件依赖</a> <br><a class="link" href="dependency_management.html#sub:file_dependencies">File dependency</a></td> 
         <td>对本地文件系统上一组文件的依赖<br>A dependency on a set of files on the local filesystem.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:client_module_dependencies">客户端模块依赖</a> <br><a class="link" href="dependency_management.html#sub:client_module_dependencies">Client module dependency</a></td> 
         <td>对外部模块的依赖，该外部模块的工件位于某仓库中，但模块元数据由本地构建指定。当你要覆盖模块的元数据时，可以使用这种类型的依赖。 <br>A dependency on an external module, where the artifacts are located in some repository but the module meta-data is specified by the local build. You use this kind of dependency when you want to override the meta-data for the module.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:api_dependencies">Gradle API 依赖</a> <br><a class="link" href="dependency_management.html#sub:api_dependencies">Gradle API dependency</a></td> 
         <td>对当前 Gradle 版本的 API 的依赖。在开发自定义 Gradle 插件和任务类型时，使用这种依赖。 <br>A dependency on the API of the current Gradle version. You use this kind of dependency when you are developing custom Gradle plugins and task types.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:groovy_dependencies">本地 Groovy 依赖</a> <br><a class="link" href="dependency_management.html#sub:groovy_dependencies">Local Groovy dependency</a></td> 
         <td>对当前 Gradle 版本所使用的 Groovy 版本的依赖。在开发自定义 Gradle 插件和任务类型时，使用这种依赖。 <br>A dependency on the Groovy version used by the current Gradle version. You use this kind of dependency when you are developing custom Gradle plugins and task types.</td> 
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:module_dependencies"></a>50.4.1 外部模块依赖</h3>
        <h5 class="title"><a name="sub:module_dependencies"></a>50.4.1.&nbsp;External module dependencies</h5>
       </div>
      </div>
     </div>
     <p>外部模块依赖是最常见的依赖。它们引用外部仓库中的模块。 <br>External module dependencies are the most common dependencies. They refer to a module in an external repository.</p>
     <div class="example">
      <a name="moduleDependencies"></a>
      <p class="title"><b>示例 50.4. 模块依赖 - Example&nbsp;50.4.&nbsp;Module dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-core'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework:spring-core:2.5'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework:spring-aop:2.5'</span>
    runtime(
        [group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-core'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>],
        [group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.springframework'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spring-aop'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.5'</span>]
    )
    runtime(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate:hibernate:3.0.5'</span>) {
        transitive = true
    }
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hibernate'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'3.0.5'</span>, transitive: true
    runtime(group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hibernate'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'3.0.5'</span>) {
        transitive = true
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>有关更多的例子和完整的参考，请参阅<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code> </a> 。 <br>See <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> for more examples and a complete reference.</p>
     <p>Gradle 为模块依赖提供了不同的标记法，有字符串表示法和映射表示法。模块依赖有 API 可以让你进一步配置，请查看 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" target="_top"><code class="classname">ExternalModuleDependency</code></a> 了解有关该 API 的所有内容。该 API 提供了属性和配置方法。通过字符串表示法，你可以定义一个属性子集。而通过映射表示法，你可以定义所有属性。要访问完整的 API（包括映射或字符串表示法），你可以通过一个闭包将一个依赖指定给配置。 <br>Gradle provides different notations for module dependencies. There is a string notation and a map notation. A module dependency has an API which allows for further configuration. Have a look at <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" target="_top"><code class="classname">ExternalModuleDependency</code></a> to learn all about the API. This API provides properties and configuration methods. Via the string notation you can define a subset of the properties. With the map notation you can define all properties. To have access to the complete API, either with the map or with the string notation, you can assign a single dependency to a configuration together with a closure.</p>
     <p>如果你定义了一个模块依赖，Gradle 将在仓库中查找相应的模块描述符文件（<code class="filename">pom.xml</code> 或 <code class="filename">ivy.xml</code>）。如果存在这样的模块描述符文件，它会进行解析，并下载此模块的工件（如 <code class="filename">hibernate-3.0.5.jar</code>）及其依赖（如 cglib）。如果不存在这样的模块描述符文件，Gradle将查找名为 <code class="filename">hibernate-3.0.5.jar</code> 的文件。在 Maven 中，一个模块只能有一个工件。在 Gradle 和 Ivy 中，一个模块可以有多个工件。每个工件都可以有一组不同的依赖。 <br>If you declare a module dependency, Gradle looks for a corresponding module descriptor file (<code class="filename">pom.xml</code> or <code class="filename">ivy.xml</code>) in the repositories. If such a module descriptor file exists, it is parsed and the artifacts of this module (e.g. <code class="filename">hibernate-3.0.5.jar</code>) as well as its dependencies (e.g. cglib) are downloaded. If no such module descriptor file exists, Gradle looks for a file called <code class="filename">hibernate-3.0.5.jar</code> to retrieve. In Maven, a module can have one and only one artifact. In Gradle and Ivy, a module can have multiple artifacts. Each artifact can have a different set of dependencies.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:multi_artifact_dependencies"></a>50.4.1.1. 依赖有多个工件的模块</h4>
         <h6 class="title"><a name="ssub:multi_artifact_dependencies"></a>50.4.1.1.&nbsp;Depending on modules with multiple artifacts</h6>
        </div>
       </div>
      </div> 如前所述，一个 Maven 模块只有一个工件。因此，当你的项目依赖于一个 Maven 模块时，这个模块的工件是什么会很明显。而对于 Gradle 或 Ivy 情况就不同了。Ivy 的依赖描述符（
      <code class="filename">ivy.xml</code>）可以声明多个工件。关于这一点的更多信息请参阅关于 
      <code class="filename">ivy.xml</code>的 Ivy 参考文档。在 Gradle 中，当你在一个 Ivy 模块上声明依赖时，实际上是在该模块的 
      <code class="literal">default</code> 配置上声明了一个依赖。所以你实际上依赖的工件集（通常是一些 jar 包），是与该模块的 
      <code class="literal">default</code> 配置相关联的工件集。以下是这个问题上的一些情况： 
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">模块的 <code class="literal">default</code> 配置包含了不需要的工件。你应该仅声明对所需工件的依赖，而不是依赖于整个配置。 <br>The <code class="literal">default</code> configuration of a module contains undesired artifacts. Rather than depending on the whole configuration, a dependency on just the desired artifacts is declared.</li>
        <li class="listitem">所需的工件属于非 <code class="literal">default</code> 配置。该配置被显式地命名为依赖声明的一部分。 <br>The desired artifact belongs to a configuration other than <code class="literal">default</code>. That configuration is explicitly named as part of the dependency declaration.</li>
       </ul>
      </div> 还有一些其他情况，需要微调依赖声明。有关示例及完整的依赖声明的参考，请参阅 
      <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>。 
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="ssub:artifact_dependencies"></a>50.4.1.2. 仅工件表示法</h4>
         <h6 class="title"><a name="ssub:artifact_dependencies"></a>50.4.1.2.&nbsp;Artifact only notation</h6>
        </div>
       </div>
      </div>
      <p>如上所述，如果找不到模块描述符文件，那么默认情况下 Gradle 会下载一个与模块名称相同的 jar。但有时候，即便仓库中包含了模块描述符，你也希望只下载工件 jar 而不下载它的依赖。<sup>[<a href="#ftn.N14D1D" name="N14D1D" class="footnote">14</a>]</sup> 有时候你希望从仓库中下载没有模块描述符的 zip。 Gradle 提供了 <span class="emphasis"><em>仅工件</em></span> 表示法，用于这些案例——只需要对你想要下载的扩展名前加个 <code class="literal">'@'</code> 符号： <br>As said above, if no module descriptor file can be found, Gradle by default downloads a jar with the name of the module. But sometimes, even if the repository contains module descriptors, you want to download only the artifact jar, without the dependencies. <sup>[<a href="#ftn.N14D1D" name="N14D1D" class="footnote">14</a>]</sup> And sometimes you want to download a zip from a repository, that does not have module descriptors. Gradle provides an <span class="emphasis"><em>artifact only</em></span> notation for those use cases - simply prefix the extension that you want to be downloaded with <code class="literal">'@'</code> sign:</p>
      <div class="example">
       <a name="artifactOnly"></a>
       <p class="title"><b>示例50.5.&nbsp;仅工件表示法 - Example&nbsp;50.5.&nbsp;Artifact only notation</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">dependencies {
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.groovy:groovy:2.2.0@jar"</span>
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.groovy'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'2.2.0'</span>, ext: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'jar'</span>
}</pre>
       </div>
      </div>
      <p><br class="example-break"> 仅工件表示法将创建只下载具有指定扩展名的工件文件的模块依赖，而忽略现有的模块描述符。 <br><br class="example-break"> An artifact only notation creates a module dependency which downloads only the artifact file with the specified extension. Existing module descriptors are ignored.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:classifiers"></a>50.4.1.3.分类器</h4>
         <h6 class="title"><a name="sub:classifiers"></a>50.4.1.3.&nbsp;Classifiers</h6>
        </div>
       </div>
      </div>
      <p>Maven 依赖管理有分类器的概念， <sup>[<a href="#ftn.N14D3B" name="N14D3B" class="footnote">15</a>]</sup> Gradle 支持这一点。如果你想从 Maven 仓库中获取分类的依赖，可以这样写： <br>The Maven dependency management has the notion of classifiers. <sup>[<a href="#ftn.N14D3B" name="N14D3B" class="footnote">15</a>]</sup> Gradle supports this. To retrieve classified dependencies from a Maven repository you can write:</p>
      <div class="example">
       <a name="classifier"></a>
       <p class="title"><b>示例 50.6. 使用分类器的依赖 - Example&nbsp;50.6.&nbsp;Dependency with classifier</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">compile <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.test.classifiers:service:1.0:jdk15@jar"</span>
    otherConf group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.test.classifiers'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'service'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>, classifier: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'jdk14'</span></pre>
       </div>
      </div>
      <br class="example-break">
      <p>如上面的第一行所示，分类器可以和仅工件表示法一起用。 <br>As can be seen in the first line above, classifiers can be used together with artifact only notation.</p>
     </div>
     <p>要遍历一个配置的依赖工件很容易：<br>It is easy to iterate over the dependency artifacts of a configuration:</p>
     <div class="example">
      <a name="externalDependencies"></a>
      <p class="title"><b>示例 50.7. 遍历一个配置 - Example&nbsp;50.7.&nbsp;Iterating over a configuration</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">task listJars &lt;&lt; {
    configurations.compile.each { File file -&gt; println file.name }
}</pre>
       <p><strong class="userinput"><code>gradle -q listJars</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q listJars</code></strong></p>
       <pre class="screen">&gt; gradle -q listJars
hibernate-core-3.6.7.Final.jar
antlr-2.7.6.jar
commons-collections-3.1.jar
dom4j-1.6.1.jar
hibernate-commons-annotations-3.2.0.Final.jar
hibernate-jpa-2.0-api-1.0.1.Final.jar
jta-1.1.jar
slf4j-api-1.6.1.jar</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:client_module_dependencies"></a>50.4.2. 客户端模块依赖</h3>
        <h5 class="title"><a name="sub:client_module_dependencies"></a>50.4.2.&nbsp;Client module dependencies</h5>
       </div>
      </div>
     </div>
     <p>客户端模块依赖允许直接在构建脚本中声明 <span class="emphasis"><em>传递</em></span> 依赖，它们是外部仓库中模块描述符的替代者。 <br>Client module dependencies allow to declare <span class="emphasis"><em>transitive</em></span> dependencies directly in the build script. They are a replacement for a module descriptor in an external repository.</p>
     <div class="example">
      <a name="client-modules"></a>
      <p class="title"><b>示例 50.8. 客户端模块依赖——传递依赖 - Example&nbsp;50.8.&nbsp;Client module dependencies - transitive dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime module(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.codehaus.groovy:groovy:2.3.3"</span>) {
        dependency(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"commons-cli:commons-cli:1.0"</span>) {
            transitive = false
        }
        module(group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.apache.ant'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'ant'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.9.3'</span>) {
            dependencies <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant-launcher:1.9.3@jar"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant-junit:1.9.3"</span>
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>这里声明了一个对 Groovy 的依赖。Groovy 本身也有依赖。但是 Gradle 不会去查找 XML 描述符来找出它的依赖，而是从构建文件中获取信息。客户端模块的依赖可以是正常模块依赖或工件依赖，或者是另一个客户端模块。还请查看 API 文档：<a class="ulink" href="../javadoc/org/gradle/api/artifacts/ClientModule.html" target="_top"><code class="classname">ClientModule</code></a> <br>This declares a dependency on Groovy. Groovy itself has dependencies. But Gradle does not look for an XML descriptor to figure them out but gets the information from the build file. The dependencies of a client module can be normal module dependencies or artifact dependencies or another client module. Have also a look at the API documentation: <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ClientModule.html" target="_top"><code class="classname">ClientModule</code></a></p>
     <p>当前版本的客户端模块中有一个限制。假设你的项目是一个库，你想要将这个库上传到公司的 Maven 或 Ivy 仓库，Gradle 会将项目的 jar 包与依赖的 XML 描述符文件一起上传到公司仓库中。如果你使用了客户端模块，那么 XML 描述符文件中的依赖声明就会不正确。我们会在 Gradle 的未来版本中改善这一点。 <br>In the current release client modules have one limitation. Let's say your project is a library and you want this library to be uploaded to your company's Maven or Ivy repository. Gradle uploads the jars of your project to the company repository together with the XML descriptor file of the dependencies. If you use client modules the dependency declaration in the XML descriptor file is not correct. We will improve this in a future release of Gradle.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:project_dependencies"></a>50.4.3. 项目依赖</h3>
        <h5 class="title"><a name="sub:project_dependencies"></a>50.4.3.&nbsp;Project dependencies</h5>
       </div>
      </div>
     </div>
     <p>对于多项目构建，Gradle 能区分外部依赖与作为多项目构建的一部分的某个子项目上的依赖。对于后者，你可以声明<em class="firstterm">项目依赖</em>。 <br>Gradle distinguishes between external dependencies and dependencies on projects which are part of the same multi-project build. For the latter you can declare <em class="firstterm">Project Dependencies</em>.</p>
     <div class="example">
      <a name="project-dependencies"></a>
      <p class="title"><b>示例 50.9. 项目依赖 - Example&nbsp;50.9.&nbsp;Project dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile project(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':shared'</span>)
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>详细信息请参阅<a class="ulink" href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" target="_top"><code class="classname">ProjectDependency</code></a>的 API 文档。 <br>For more information see the API documentation for <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" target="_top"><code class="classname">ProjectDependency</code></a></p>
     <p>多项目构建将在<a class="xref" href="multi_project_builds.html">第 56 章，《<i>多项目构建</i>》</a>中进行详述。 <br>Multi-project builds are discussed in<a class="xref" href="multi_project_builds.html">Chapter&nbsp;56, <i>Multi-project Builds</i></a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:file_dependencies"></a>50.4.4. 文件依赖</h3>
        <h5 class="title"><a name="sub:file_dependencies"></a>50.4.4.&nbsp;File dependencies</h5>
       </div>
      </div>
     </div>
     <p>文件依赖可以让你直接将一组文件添加到配置中，而不首先把它们添加到仓库。如果你无法或不想将某些文件放在仓库里，或者是如果你不想使用任何仓库来存储依赖的话，这会很有用。 <br>File dependencies allow you to directly add a set of files to a configuration, without first adding them to a repository. This can be useful if you cannot, or do not want to, place certain files in a repository. Or if you do not want to use any repositories at all for storing your dependencies.</p>
     <p>要将一些文件添加为配置的依赖，你只需要把<a class="link" href="working_with_files.html#sec:file_collections">文件集合</a>作为依赖传入： <br>To add some files as a dependency for a configuration, you simply pass a <a class="link" href="working_with_files.html#sec:file_collections">file collection</a> as a dependency:</p>
     <div class="example">
      <a name="file-dependencies"></a>
      <p class="title"><b>示例 50.10. 文件依赖 - Example&nbsp;50.10.&nbsp;File dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime files(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs/a.jar'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs/b.jar'</span>)
    runtime fileTree(dir: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'libs'</span>, include: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'*.jar'</span>)
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>项目发布的依赖描述符不包含文件依赖，但同一个构建内的传递项目依赖会包含它。这意味着，文件依赖可以在同一个构建内使用，但不能在当前构建之外使用。 <br>File dependencies are not included in the published dependency descriptor for your project. However, file dependencies are included in transitive project dependencies within the same build. This means they cannot be used outside the current build, but they can be used with the same build.</p>
     <p> 你可以声明哪些任务将产生文件依赖的文件。例如，你可以在通过构建生成文件的时候这样做。 <br>You can declare which tasks produce the files for a file dependency. You might do this when, for example, the files are generated by the build.</p>
     <div class="example">
      <a name="generatedFileDependencies"></a>
      <p class="title"><b>示例 50.11. 生成文件依赖 - Example&nbsp;50.11.&nbsp;Generated file dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile files(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$buildDir/classes"</span>) {
        builtBy <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compile'</span>
    }
}

task compile &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'compiling classes'</span>
}

task list(dependsOn: configurations.compile) &lt;&lt; {
    println <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"classpath = ${configurations.compile.collect {File file -&gt; file.name}}"</span>
}</pre>
       <p><strong class="userinput"><code>gradle -q list</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q list</code></strong></p>
       <pre class="screen">&gt; gradle -q list
compiling classes
classpath = [classes]</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:api_dependencies"></a>50.4.5. Gradle API 依赖</h3>
        <h5 class="title"><a name="sub:api_dependencies"></a>50.4.5.&nbsp;Gradle API Dependency</h5>
       </div>
      </div>
     </div>
     <p>你可以通过使用 <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" target="_top"><code class="classname">DependencyHandler.gradleApi()</code></a> 方法，来声明一个当前版本的 Gradle API 的依赖。 <br>You can declare a dependency on the API of the current version of Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" target="_top"><code class="classname">DependencyHandler.gradleApi()</code></a> method. This is useful when you are developing custom Gradle tasks or plugins.</p>
     <div class="example">
      <a name="gradle-api-dependencies"></a>
      <p class="title"><b>示例 50.12. Gradle API 依赖 - Example&nbsp;50.12.&nbsp;Gradle API dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile gradleApi()
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:groovy_dependencies"></a>50.4.6. 本地 Groovy 依赖</h3>
        <h5 class="title"><a name="sub:groovy_dependencies"></a>50.4.6.&nbsp;Local Groovy Dependency</h5>
       </div>
      </div>
     </div>
     <p>你可以通过使用 <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" target="_top"><code class="classname">DependencyHandler.localGroovy()</code></a> 方法，来声明对与 Gradle 一起分发的 Groovy 的依赖。当你使用 Groovy 开发自定义 Gradle 任务或插件时，这会很有用。 <br>You can declare a dependency on the Groovy that is distributed with Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" target="_top"><code class="classname">DependencyHandler.localGroovy()</code></a> method. This is useful when you are developing custom Gradle tasks or plugins in Groovy.</p>
     <div class="example">
      <a name="local-groovy-dependencies"></a>
      <p class="title"><b>示例 50.13. Gradle 的 Groovy 依赖 - Example&nbsp;50.13.&nbsp;Gradle's Groovy dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile localGroovy()
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:exclude_transitive_dependencies"></a>50.4.7. 排除传递依赖</h3>
        <h5 class="title"><a name="sub:exclude_transitive_dependencies"></a>50.4.7.&nbsp;Excluding transitive dependencies</h5>
       </div>
      </div>
     </div>
     <p>通过配置或是依赖，你可以排除掉<span class="emphasis"><em>传递</em></span>依赖： <br>You can exclude a <span class="emphasis"><em>transitive</em></span> dependency either by configuration or by dependency:</p>
     <div class="example">
      <a name="exclude-dependencies"></a>
      <p class="title"><b>示例 50.14. 排除传递依赖 - Example&nbsp;50.14.&nbsp;Excluding transitive dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">configurations {
    compile.exclude module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'commons'</span>
    all*.exclude group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle.test.excludes'</span>, module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'reports'</span>
}

dependencies {
    compile(<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.gradle.test.excludes:api:1.0"</span>) {
        exclude module: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'shared'</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>如果你为一个特定配置定义了排除，那么解析这个配置或任何继承的配置时，所有依赖的被排除的传递依赖都会被过滤掉。如果你要从所有配置中排除传递依赖，那么可以使用一种简明的方式，使用 Groovy 的 spread-dot 运算符来表示此操作，如示例中所示。定义排除时，你可以只指定组织或只指定模块名称，或者两者都指定。另请查看 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/Dependency.html" target="_top"><code class="classname">Dependency</code></a> 和 <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a> 的 API 文档。 <br>If you define an exclude for a particular configuration, the excluded transitive dependency will be filtered for all dependencies when resolving this configuration or any inheriting configuration. If you want to exclude a transitive dependency from all your configurations you can use the Groovy spread-dot operator to express this in a concise way, as shown in the example. When defining an exclude, you can specify either only the organization or only the module name or both. Have also a look at the API documentation of <a class="ulink" href="../javadoc/org/gradle/api/artifacts/Dependency.html" target="_top"><code class="classname">Dependency</code></a> and <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.</p>
     <p> 并非每个传递依赖都可以排除_某些传递依赖可能对于入驻正确的运行时行为至关重要。通常，可以排除的传递依赖，是在运行时不需要，或者是保证在目标环境或平台上可用。 <br>Not every transitive dependency can be excluded - some transitive dependencies might be essential for correct runtime behavior of the application. Generally, one can exclude transitive dependencies that are either not required by runtime or that are guaranteed to be available on the target environment/platform.</p>
     <p> 你的排除应该是对依赖还是配置？事实表明，在大多数情况下，你希望使用的是对配置的排除。以下是为什么想要排除传递依赖的一些示例原因。记住，对于某些用例，存在比排除更有效的解决方案！ <br>Should you exclude per-dependency or per-configuration? It turns out that in majority of cases you want to use the per-configuration exclusion. Here are the some exemplary reasons why one might want to exclude a transitive dependency. Bear in mind that for some of those use cases there are better solutions than exclusions!</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem">由于许可的原因，依赖不理想。<br>The dependency is undesired due to licensing reasons.</li>
       <li class="listitem">这个依赖在任何的远程仓库中都不可用。<br>The dependency is not available in any of remote repositories.</li>
       <li class="listitem">在运行时不需要这个依赖。<br>The dependency is not needed for runtime.</li>
       <li class="listitem">这个依赖有版本与所需要的的版本冲突。对于这个用例，请参考<a class="xref" href="dependency_management.html#sub:version_conflicts">第 50.2.3 节，《解决版本冲突》</a>和关于 <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> 的文档，以了解这个问题的可能更好的解决方案。 <br>The dependency has a version that conflicts with a desired version. For that use case please refer to <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;50.2.3, “Resolve version conflicts”</a> and the documentation on <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for a potentially better solution to the problem.</li>
      </ul>
     </div>
     <p> 基本上，大多数情况下，应该对配置排除依赖，这样依赖声明就更加明确。它也更加准确，因为对依赖的排除规则不保证给定的传递依赖不会显示在配置中。例如，其他某些不含任何排除规则的依赖可能会带上那个不需要的传递依赖。 <br>Basically, in most of the cases excluding the transitive dependency should be done per configuration. This way the dependency declaration is more explicit. It is also more accurate because a per-dependency exclude rule does not guarantee the given transitive dependency does not show up in the configuration. For example, some other dependency, which does not have any exclude rules, might pull in that unwanted transitive dependency.</p>
     <p> 其他有关依赖排除的示例，可以参考 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html" target="_top"> <code class="classname">ModuleDependency</code></a> 或 <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>。 <br>Other examples of the dependency exclusions can be found in the reference for <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html" target="_top"><code class="classname">ModuleDependency</code></a> or <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N14E30"></a>50.4.8. 可选属性</h3>
        <h5 class="title"><a name="N14E30"></a>50.4.8.&nbsp;Optional attributes</h5>
       </div>
      </div>
     </div>
     <p><a name="para:dependencies_with_empty_attributes"></a>依赖的所有属性除了名称之外都是可选的。这取决于仓库类型，这些信息实际上用于查找仓库中的依赖。请参阅 <a class="xref" href="dependency_management.html#sec:repositories">第50.6节，《存储库》</a>。 比如如果你使用 Maven 仓库，那么就需要定义组，名称及版本。如果你使用文件系统仓库，那么可能只需要名称或名称及版本。 <br><a name="para:dependencies_with_empty_attributes"></a>All attributes for a dependency are optional, except the name. It depends on the repository type, which information is need for actually finding the dependencies in the repository. See <a class="xref" href="dependency_management.html#sec:repositories">Section&nbsp;50.6, “Repositories”</a>. If you work for example with Maven repositories, you need to define the group, name and version. If you work with filesystem repositories you might only need the name or the name and the version.</p>
     <div class="example">
      <a name="dependenciesWithEmptyAttributes"></a>
      <p class="title"><b>示例 50.15. 依赖的可选属性 - Example&nbsp;50.15.&nbsp;Optional attributes of dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":junit:4.10"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">":testng"</span>
    runtime name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'testng'</span> 
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p><a name="para:notation_collections"></a>你也可以将依赖的集合或数组指定给配置： <br><a name="para:notation_collections"></a>You can also assign collections or arrays of dependency notations to a configuration:</p>
     <div class="example">
      <a name="listGrouping"></a>
      <p class="title"><b>示例 50.16. 依赖的集合和数组 - Example&nbsp;50.16.&nbsp;Collections and arrays of dependencies</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">List groovy = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.codehaus.groovy:groovy-all:2.3.3@jar"</span>,
               <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"commons-cli:commons-cli:1.0@jar"</span>,
               <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.apache.ant:ant:1.9.3@jar"</span>]
List hibernate = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.hibernate:hibernate:3.0.5@jar'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'somegroup:someorg:1.0@jar'</span>]
dependencies {
    runtime groovy, hibernate
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:dependency_configurations"></a>50.4.9. 依赖配置</h3>
        <h5 class="title"><a name="sec:dependency_configurations"></a>50.4.9.&nbsp;Dependency configurations</h5>
       </div>
      </div>
     </div>
     <p>在 Gradle 中，一个依赖可以有不同的配置（就像你的项目可以有不同的配置）。如果未显式指定任何内容，那么 Gradle 会使用依赖的默认配置。对于 Maven 仓库的依赖，默认配置是唯一可用的配置。 如果你使用 Ivy 仓库并且想为依赖声明一个非默认配置，那么必须使用映射表示法并声明： <br>In Gradle a dependency can have different configurations (as your project can have different configurations). If you don't specify anything explicitly, Gradle uses the default configuration of the dependency. For dependencies from a Maven repository, the default configuration is the only available one anyway. If you work with Ivy repositories and want to declare a non-default configuration for your dependency you have to use the map notation and declare:</p>
     <div class="example">
      <a name="dependencyConfigurations"></a>
      <p class="title"><b>示例 50.17. 依赖配置 - Example&nbsp;50.17.&nbsp;Dependency configurations</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    runtime group: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.somegroup'</span>, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'somedependency'</span>, version: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.0'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'someConfiguration'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>要对项目依赖执行同样操作，你需要声明：<br>To do the same for project dependencies you need to declare:</p>
     <div class="example">
      <a name="dependencyConfigurationsProjects"></a>
      <p class="title"><b>示例 50.18. 项目的依赖配置 - Example&nbsp;50.18.&nbsp;Dependency configurations for project</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    compile project(path: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">':api'</span>, configuration: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'spi'</span>)
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N14E6C"></a>50.4.10.&nbsp;依赖报告</h3>
        <h5 class="title"><a name="N14E6C"></a>50.4.10.&nbsp;Dependency reports</h5>
       </div>
      </div>
     </div>
     <p>你可以从命令行生成依赖报告（请参阅 <a class="xref" href="tutorial_gradle_command_line.html#para:commandline_dependency_report">第11.6.4节，《列示项目依赖》</a>）。在项目报告插件的帮助下（请参阅 <a class="xref" href="project_reports_plugin.html">第41章，《<i>项目报告插件</i>》</a>) ，你的构建能够创建这样一个报告。 <br>You can generate dependency reports from the command line (see <a class="xref" href="tutorial_gradle_command_line.html#para:commandline_dependency_report">Section&nbsp;11.6.4, “Listing project dependencies”</a>). With the help of the Project report plugin (see <a class="xref" href="project_reports_plugin.html">Chapter&nbsp;41, <i>The Project Report Plugin</i></a>) such a report can be created by your build.</p>
     <p> 从 Gradle 1.2 起，还有一个新的程序化 API 来访问已解析的依赖信息。这个依赖报告（请参阅上一段）正是使用这个API。 这个 API 可以让你查看解析后的依赖图，并提供依赖的有关信息。在即将到来的发行版中，API 将提供更多有关解析结果的信息。有关此 API 的更多信息，请参阅 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult()" target="_top"><code class="classname">ResolvableDependences.getResolutionResult()</code></a>上的 javadocs。 <a class="ulink" href="../javadoc/org/gradle/api/artifacts/result/ResolutionResult.html" target="_top"><code class="classname">ResolutionResult</code></a> API 的可能用法： <br>Since Gradle 1.2 there is also a new programmatic API to access the resolved dependency information. The dependency reports (see the previous paragraph) are using this API under the covers. The API lets you to walk the resolved dependency graph and provides information about the dependencies. With the coming releases the API will grow to provide more information about the resolution result. For more information about the API please refer to the javadocs on <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ResolvableDependencies.html#getResolutionResult()" target="_top"><code class="classname">ResolvableDependencies.getResolutionResult()</code></a>. Potential usages of the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/result/ResolutionResult.html" target="_top"><code class="classname">ResolutionResult</code></a> API:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem">为你的用例定制创建高级的依赖报告。<br>Creation of advanced dependency reports tailored to your use case.</li>
       <li class="listitem">启用构建逻辑以基于依赖图的内容来做决策。<br>Enabling the build logic to make decisions based on the content of the dependency graph.</li>
      </ul>
     </div>
     <p> </p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:working_with_dependencies"></a>50.5. 使用依赖</h2>
       <h4 class="title"><a name="sec:working_with_dependencies"></a>50.5.&nbsp;Working with dependencies</h4>
      </div>
     </div>
    </div>
    <p>下面的示例我们使用以下的依赖设置：<br>For the examples below we have the following dependencies setup:</p>
    <div class="example">
     <a name="configurationHandlingSetup"></a>
     <p class="title"><b>示例 50.19. Configuration.copy - Example&nbsp;50.19.&nbsp;Configuration.copy</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">configurations {
    sealife
    alllife
}

dependencies {
    sealife <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.mammals:orca:1.0"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:shark:1.0"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:1.0"</span>
    alllife configurations.sealife
    alllife <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds:albatros:1.0"</span>
}</pre>
     </div>
    </div>
    <br class="example-break">
    <p>这些依赖有以下的传递依赖：<br>The dependencies have the following transitive dependencies:</p>
    <p>shark-1.0 -&gt; seal-2.0, tuna-1.0</p>
    <p>orca-1.0 -&gt; seal-1.0</p>
    <p>tuna-1.0 -&gt; herring-1.0</p>
    <p>你可以使用配置来访问声明的依赖或其中的子集： <br>You can use the configuration to access the declared dependencies or a subset of those:</p>
    <div class="example">
     <a name="configurationHandlingDependencies"></a>
     <p class="title"><b>示例 50.20. 访问已声明的依赖 - Example&nbsp;50.20.&nbsp;Accessing declared dependencies</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task dependencies &lt;&lt; {
    configurations.alllife.dependencies.each { dep -&gt; println dep.name }
    println()
    configurations.alllife.allDependencies.each { dep -&gt; println dep.name }
    println()
    configurations.alllife.allDependencies.findAll { dep -&gt; dep.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { dep -&gt; println dep.name }
}</pre>
      <p><strong class="userinput"><code>gradle -q dependencies</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q dependencies</code></strong></p>
      <pre class="screen">&gt; gradle -q dependencies
albatros

albatros
orca
shark
tuna

albatros
shark
tuna</pre>
     </div>
    </div>
    <br class="example-break">
    <p><code class="code">dependencies</code> 只返回了明确属于配置的依赖，<code class="code">allDependencies</code> 则包括了扩展配置的依赖。 <br><code class="code">dependencies</code> returns only the dependencies belonging explicitly to the configuration. <code class="code">allDependencies</code> includes the dependencies from extended configurations.</p>
    <p>要获得配置依赖的库文件，你可以执行如下操作： <br>To get the library files of the configuration dependencies you can do:</p>
    <div class="example">
     <a name="configurationHandlingAllFiles"></a>
     <p class="title"><b>示例 50.21. Configuration.files - Example&nbsp;50.21.&nbsp;Configuration.files</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task allFiles &lt;&lt; {
    configurations.sealife.files.each { file -&gt;
        println file.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q allFiles</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q allFiles</code></strong></p>
      <pre class="screen">&gt; gradle -q allFiles
orca-1.0.jar
shark-1.0.jar
tuna-1.0.jar
herring-1.0.jar
seal-2.0.jar</pre>
     </div>
    </div>
    <br class="example-break">
    <p>有时你想一些配置依赖的子集（例如单个依赖）的库文件。 <br>Sometimes you want the library files of a subset of the configuration dependencies (e.g. of a single dependency).</p>
    <div class="example">
     <a name="configurationHandlingFiles"></a>
     <p class="title"><b>示例&nbsp;50.22.&nbsp;特殊的 Configuration.files - Example&nbsp;50.22.&nbsp;Configuration.files with spec</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task files &lt;&lt; {
    configurations.sealife.files { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
        println file.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q files</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q files</code></strong></p>
      <pre class="screen">&gt; gradle -q files
orca-1.0.jar
seal-2.0.jar</pre>
     </div>
    </div>
    <br class="example-break">
    <p><code class="code">Configuration.files</code> 方法总是获取 <span class="emphasis"><em>整个</em></span> 配置的所有工件，然后它通过指定的依赖对检索到的文件进行过滤。正如你在示例中所看到的，传递依赖会被包含在内。 <br>The <code class="code">Configuration.files</code> method always retrieves all artifacts of the <span class="emphasis"><em>whole</em></span> configuration. It then filters the retrieved files by specified dependencies. As you can see in the example, transitive dependencies are included.</p>
    <p>你也可以复制一个配置。你可以选择仅复制原配置中的一部分依赖。复制方法有两种：<code class="code">copy</code> 方法仅复制显式属于配置的依赖； <code class="code">copyRecursive</code> 方法会复制所有的依赖，包括扩展配置中的依赖。 <br>You can also copy a configuration. You can optionally specify that only a subset of dependencies from the original configuration should be copied. The copying methods come in two flavors. The <code class="code">copy</code> method copies only the dependencies belonging explicitly to the configuration. The <code class="code">copyRecursive</code> method copies all the dependencies, including the dependencies from extended configurations.</p>
    <div class="example">
     <a name="configurationHandlingCopy"></a>
     <p class="title"><b>示例 50.23. Configuration.copy - Example&nbsp;50.23.&nbsp;Configuration.copy</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task copy &lt;&lt; {
    configurations.alllife.copyRecursive { dep -&gt; dep.name != <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.allDependencies.each { dep -&gt;
        println dep.name
    }
    println()
    configurations.alllife.copy().allDependencies.each { dep -&gt;
        println dep.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q copy</code></strong> 的输出结果<br>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p>
      <pre class="screen">&gt; gradle -q copy
albatros
shark
tuna

albatros</pre>
     </div>
    </div>
    <br class="example-break">
    <p>请务必注意，复制的配置所返回的文件，通常并不总是与原配置的依赖子集所返回的文件相同。 如果子集的依赖与不属于子集的依赖发生版本冲突，那么解析结果可能会不同。 <br>It is important to note that the returned files of the copied configuration are often but not always the same than the returned files of the dependency subset of the original configuration. In case of version conflicts between dependencies of the subset and dependencies not belonging to the subset the resolve result might be different.</p>
    <div class="example">
     <a name="configurationHandlingCopyVsFiles"></a>
     <p class="title"><b>示例 50.24. Configuration.copy 与 Configuration.files - Example&nbsp;50.24.&nbsp;Configuration.copy vs. Configuration.files</b></p>
     <div class="example-contents">
      <p><code class="filename">build.gradle</code></p>
      <pre class="programlisting">task copyVsFiles &lt;&lt; {
    configurations.sealife.copyRecursive { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
        println file.name
    }
    println()
    configurations.sealife.files { dep -&gt; dep.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'orca'</span> }.each { file -&gt;
        println file.name
    }
}</pre>
      <p><strong class="userinput"><code>gradle -q copyVsFiles</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q copyVsFiles</code></strong></p>
      <pre class="screen">&gt; gradle -q copyVsFiles
orca-1.0.jar
seal-1.0.jar

orca-1.0.jar
seal-2.0.jar</pre>
     </div>
    </div>
    <br class="example-break">
    <p>在上面的例子中，<code class="code">orca</code> 依赖于 <code class="code">seal-1.0</code> ，而 <code class="code">shark</code> 依赖于 <code class="code">seal-2.0</code>。 原配置因此有版本冲突，所以解析为较新的 <code class="code">seal-2.0</code> 版本。 <code class="code"></code> 方法也因此返回 <code class="code">seal-2.0</code> 作为 <code class="code">orca</code> 的传递依赖。而复制的配置只有 <code class="code">orca</code> 依赖，故而不存在版本冲突，所以 <code class="code">seal-1.0</code> 作为传递依赖被返回。 <br>In the example above, <code class="code">orca</code> has a dependency on <code class="code">seal-1.0</code> whereas <code class="code">shark</code> has a dependency on<code class="code">seal-2.0</code>. The original configuration has therefore a version conflict which is resolved to the newer <code class="code">seal-2.0</code> version. The <code class="code">files</code> method therefore returns <code class="code">seal-2.0</code> as a transitive dependency of<code class="code">orca</code>. The copied configuration only has <code class="code">orca</code> as a dependency and therefore there is no version conflict and <code class="code">seal-1.0</code> is returned as a transitive dependency.</p>
    <p>一旦一个配置被配置，那它就是不可变的了。如果去修改它或它的某个依赖的状态就会引发异常。你始终可以复制已经解析的配置，这个复制的配置处于未解析状态，并且可以重新解析。 <br>Once a configuration is resolved it is immutable. Changing its state or the state of one of its dependencies will cause an exception. You can always copy a resolved configuration. The copied configuration is in the unresolved state and can be freshly resolved.</p>
    <p>想了解更多关于这个配置类的 API，请参阅 API 文档：<a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>。 <br>To learn more about the API of the configuration class see the API documentation: <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.</p>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:repositories"></a>50.6. 仓库</h2>
       <h4 class="title"><a name="sec:repositories"></a>50.6.&nbsp;Repositories</h4>
      </div>
     </div>
    </div>
    <p>基于Apache Ivy 的 Gradle 仓库管理对仓库布局和检索策略的有很大的灵活性。 此外，Gradle 还提供了多种便捷的方法来添加预配置的仓库。 <br>Gradle repository management, based on Apache Ivy, gives you a lot of freedom regarding repository layout and retrieval policies. Additionally Gradle provides various convenience method to add pre-configured repositories.</p>
    <p>你可以配置任意数量的仓库，每个仓库都会被 Gradle 独立处理。如果 Gradle 在一个特定的仓库中找到模块描述符，那么它将尝试从 <span class="emphasis"><em>同一仓库</em></span>中下载该模块的所有工件。虽然模块元数据和模块工件必须位于同一仓库中，但也可能单个仓库由多个 URL 组成，同时提供多个位置来搜索元数据文件和 jar 文件。 <br>You may configure any number of repositories, each of which is treated independently by Gradle. If Gradle finds a module descriptor in a particular repository, it will attempt to download all of the artifacts for that module from <span class="emphasis"><em>the same repository</em></span>. Although module meta-data and module artifacts must be located in the same repository, it is possible to compose a single repository of multiple URLs, giving multiple locations to search for meta-data files and jar files.</p>
    <p>可以声明几种不同类型的仓库：<br>There are several different types of repositories you can declare:</p>
    <div xmlns:xslthl="http://xslthl.sf.net" class="table">
     <p class="title"><b>表 50.2. 仓库类型 - Table&nbsp;50.2.&nbsp;Repository types</b></p>
     <div class="table-contents">
      <table id="N14F46">
       <thead>
        <tr> 
         <td>类型<br>Type</td> 
         <td>描述<br>Description</td> 
        </tr>
       </thead>
       <tbody>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_central">Maven 中央仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_central">Maven central repository</a></td> 
         <td>一个在 Maven Cemtral 中查找依赖的预配置仓库。<br>A pre-configured repository that looks for dependencies in Maven Central.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_jcenter">Maven JCenter 仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_jcenter">Maven JCenter repository</a></td> 
         <td>一个在 Bintray 的 Jcenter 中查找依赖的预配置仓库。<br>A pre-configured repository that looks for dependencies in Bintray's JCenter.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_local">Maven 本地仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_local">Maven local repository</a></td> 
         <td>一个在本地 Maven 仓库中查找依赖的预配置仓库。<br>A pre-configured repository that looks for dependencies in the local Maven repository.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sub:maven_repo">Maven 仓库</a> <br><a class="link" href="dependency_management.html#sub:maven_repo">Maven repository</a></td> 
         <td>一个 Maven 仓库。 可以位于本地文件系统上，或在某个远程位置。<br>A Maven repository. Can be located on the local filesystem or at some remote location.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sec:ivy_repositories">Ivy 仓库</a> <br><a class="link" href="dependency_management.html#sec:ivy_repositories">Ivy repository</a></td> 
         <td>一个 Ivy 仓库。 可以位于本地文件系统上，或在某个远程位置。<br>An Ivy repository. Can be located on the local filesystem or at some remote location.</td> 
        </tr>
        <tr> 
         <td> <a class="link" href="dependency_management.html#sec:flat_dir_resolver">Flat 目录仓库</a> <br><a class="link" href="dependency_management.html#sec:flat_dir_resolver">Flat directory repository</a></td> 
         <td>一个在本地文件系统上的简单仓库。不支持任何元数据格式。<br>A simple repository on the local filesystem. Does not support any meta-data formats.</td> 
        </tr>
       </tbody>
      </table>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:supported_transport_protocols"></a>50.6.1. 支持的仓库传输协议</h3>
        <h5 class="title"><a name="sub:supported_transport_protocols"></a>50.6.1.&nbsp;Supported repository transport protocols</h5>
       </div>
      </div>
     </div>
     <p>Maven 和 Ivy 仓库支持使用各种传输协议，当前支持以下协议： <br>Maven and Ivy repositories support the use of various transport protocols. At the moment the following protocols are supported:</p>
     <div xmlns:xslthl="http://xslthl.sf.net" class="table">
      <p class="title"><b>表50.3&nbsp;仓库传输协议 - Table&nbsp;50.3.&nbsp;Repository transport protocols</b></p>
      <div class="table-contents">
       <table id="N14FA0">
        <thead>
         <tr> 
          <td>类型<br>Type</td> 
          <td>认证方案<br>Authentication schemes</td> 
         </tr>
        </thead>
        <tbody>
         <tr> 
          <td><code class="literal">file</code></td> 
          <td>无<br>none</td> 
         </tr>
         <tr> 
          <td><code class="literal">http</code></td> 
          <td>用户名/密码<br>username/password</td> 
         </tr>
         <tr> 
          <td><code class="literal">https</code></td> 
          <td>用户名/密码<br>username/password</td> 
         </tr>
         <tr> 
          <td><code class="literal">sftp</code></td> 
          <td>用户名/密码<br>username/password</td> 
         </tr>
        </tbody>
       </table>
      </div>
     </div>
     <p>要定义仓库，请使用 <code class="literal">repositories</code> 配置块。在 <code class="literal">repositories</code> 闭包中，使用 <code class="literal">maven</code> 声明 Maven 仓库，使用 <code class="literal">ivy</code> 声明Ivy 仓库。传输协议是仓库 URL 定义的一部分。以下构建脚本演示了如何创建基于 HTTP 的 Maven 和 Ivy 仓库： <br>To define a repository use the <code class="literal">repositories</code> configuration block. Within the <code class="literal">repositories</code> closure, a Maven repository is declared with <code class="literal">maven</code>. An Ivy repository is declared with <code class="literal">ivy</code>. The transport protocol is part of the URL definition for a repository. The following build script demonstrates how to create a HTTP-based Maven and Ivy repository:</p>
     <div class="example">
      <a name="mavenIvyRepositoriesNoAuth"></a>
      <p class="title"><b>示例50.25.&nbsp;声明 Maven 和 Ivy 仓库 - Example&nbsp;50.25.&nbsp;Declaring a Maven and Ivy repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }

    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>如果仓库需要认证，那么可以提供相关的凭证。以下示例展示了如何为 SFTP 仓库提供基于用户名/密码的认证： <br>If authentication is required for a repository, the relevant credentials can be provided. The following example shows how to provide username/password-based authentication for SFTP repositories:</p>
     <div class="example">
      <a name="mavenIvyRepositoriesAuth"></a>
      <p class="title"><b>示例50.26.&nbsp;向 Maven 和 Ivy 仓库提供凭证 - Example&nbsp;50.26.&nbsp;Providing credentials to a Maven and Ivy repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sftp://repo.mycompany.com:22/maven2"</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }

    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sftp://repo.mycompany.com:22/repo"</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_central"></a>50.6.2. Maven 中央仓库</h3>
        <h5 class="title"><a name="sub:maven_central"></a>50.6.2.&nbsp;Maven central repository</h5>
       </div>
      </div>
     </div>
     <p>若要添加中央 Maven 2 仓库（<a class="ulink" href="http://repo1.maven.org/maven2" target="_top">http://repo1.maven.org/maven2</a>），只需添加下面的代码到你的构建脚本中： <br>To add the central Maven 2 repository (<a class="ulink" href="http://repo1.maven.org/maven2" target="_top">http://repo1.maven.org/maven2</a>) simply add this to your build script:</p>
     <div class="example">
      <a name="mavenCentral"></a>
      <p class="title"><b>示例 50.27. 添加 Maven 中央仓库 - Example&nbsp;50.27.&nbsp;Adding central Maven repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    mavenCentral()
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>现在 Gradle 将会在此仓库中查找你的依赖。 <br>Now Gradle will look for your dependencies in this repository.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_jcenter"></a>50.6.3. Maven JCenter 仓库</h3>
        <h5 class="title"><a name="sub:maven_jcenter"></a>50.6.3.&nbsp;Maven JCenter repository</h5>
       </div>
      </div>
     </div>
     <p><a class="ulink" href="http://bintray.com" target="_top">Bintray</a> 的 JCenter 是所有流行的 Maven OSS 工件（包括直接发布到 Bintray 的工件）的最新集合。 <br><a class="ulink" href="http://bintray.com" target="_top">Bintray</a>'s JCenter is an up-to-date collection of all popular Maven OSS artifacts, including artifacts published directly to Bintray.</p>
     <p>若要添加 JCenter Maven 仓库（<a class="ulink" href="http://jcenter.bintray.com" target="_top">http://jcenter.bintray.com</a>），只需添加下面的内容到你的构建脚本中： <br>To add the JCenter Maven repository (<a class="ulink" href="http://jcenter.bintray.com" target="_top">http://jcenter.bintray.com</a>) simply add this to your build script:</p>
     <div class="example">
      <a name="mavenJcenter"></a>
      <p class="title"><b>示例 50.28. 添加 Bintray 的 Jcenter Maven 仓库 - Example&nbsp;50.28.&nbsp;Adding Bintray's JCenter Maven repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    jcenter()
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>现在 Gradle 将会在 JCenter 仓库中查找你的依赖。 <br>Now Gradle will look for your dependencies in the JCenter repository.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_local"></a>50.6.4. 本地 Maven 仓库</h3>
        <h5 class="title"><a name="sub:maven_local"></a>50.6.4.&nbsp;Local Maven repository</h5>
       </div>
      </div>
     </div>
     <p>要把本地的 Maven 缓存用作仓库，你可以这样操作：<br>To use the local Maven cache as a repository you can do:</p>
     <div class="example">
      <a name="mavenLocalRepo"></a>
      <p class="title"><b>示例 50.29. 将本地 Maven 缓存添加为仓库： - Example&nbsp;50.29.&nbsp;Adding the local Maven cache as a repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    mavenLocal()
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>Gradle 使用与 Maven 相同的逻辑来标识本地 Maven 缓存的位置。如果在 <code class="filename">settings.xml</code> 中定义了本地仓库位置，那么将使用此位置。 <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2</code> 中的 <code class="filename">settings.xml</code> 优先级高于 <code class="filename"><em class="replaceable"><code>M2_HOME</code></em>/conf</code> 中的 <code class="filename">settings.xml</code>。如果没有 <code class="filename">settings.xml</code> 可用，Gradle将使用默认位置 <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2/repository</code>。 <br>Gradle uses the same logic as Maven to identify the location of your local Maven cache. If a local repository location is defined in a <code class="filename">settings.xml</code>, this location will be used. The <code class="filename">settings.xml</code> in <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2</code> takes precedence over the <code class="filename">settings.xml</code> in <code class="filename"><em class="replaceable"><code>M2_HOME</code></em>/conf</code>. If no <code class="filename">settings.xml</code> is available, Gradle uses the default location <code class="filename"><em class="replaceable"><code>USER_HOME</code></em>/.m2/repository</code>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:maven_repo"></a>50.6.5. Maven 仓库</h3>
        <h5 class="title"><a name="sub:maven_repo"></a>50.6.5.&nbsp;Maven repositories</h5>
       </div>
      </div>
     </div>
     <p>要添加自定义 Maven 仓库，你可以如下操作： <br>For adding a custom Maven repository you can do:</p>
     <div class="example">
      <a name="mavenLikeRepo"></a>
      <p class="title"><b>示例 50.30. 添加一个自定义的 Maven 仓库 - Example&nbsp;50.30.&nbsp;Adding custom Maven repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    maven {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>有时候一个仓库会将 POM 发布到一个位置，而 JAR 和其他工件发布在另一个位置。要定义这样的一个仓库，你可以这样： <br>Sometimes a repository will have the POMs published to one location, and the JARs and other artifacts published at another location. To define such a repository, you can do:</p>
     <div class="example">
      <a name="mavenLikeRepoWithJarRepo"></a>
      <p class="title"><b>示例 50.31. 为 JAR 文件添加额外的 Maven 仓库 - Example&nbsp;50.31.&nbsp;Adding additional Maven repositories for JAR files</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    maven {
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Look for POMs and artifacts, such as JARs, here</span>
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo2.mycompany.com/maven2"</span>
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Look for artifacts here if not found at the above location</span>
        artifactUrls <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/jars"</span>
        artifactUrls <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/jars2"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>Gradle 将会在第一个 URL 查找 POM 和 JAR 文件。如果那里找不到 JAR，那么会使用工件 URL 来查找 JAR。 <br>Gradle will look at the first URL for the POM and the JAR. If the JAR can't be found there, the artifact URLs are used to look for JARs.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N1506E"></a>50.6.5.1. 访问受密码保护的 Maven 仓库</h4>
         <h6 class="title"><a name="N1506E"></a>50.6.5.1.&nbsp;Accessing password protected Maven repositories</h6>
        </div>
       </div>
      </div>
      <p>要访问一个使用基本认证的 Maven 仓库，请在定义该仓库时指定要使用的用户名和密码： <br>To access a Maven repository which uses basic authentication, you specify the username and password to use when you define the repository:</p>
      <div class="example">
       <a name="mavenPasswordProtectedRepo"></a>
       <p class="title"><b>示例 50.32. 访问受密码保护的 Maven 仓库 - Example&nbsp;50.32.&nbsp;Accessing password protected Maven repository</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    maven {
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
      <p>建议把你的用户名和密码写在 <code class="filename">gradle.properties</code> 中，而不是直接写在构建文件上。 <br>It is advisable to keep your username and password in <code class="filename">gradle.properties</code> rather than directly in the build file.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:flat_dir_resolver"></a>50.6.6. 平面目录仓库</h3>
        <h5 class="title"><a name="sec:flat_dir_resolver"></a>50.6.6.&nbsp;Flat directory repository</h5>
       </div>
      </div>
     </div>
     <p>如果想要把一个（平面）文件系统目录用作仓库，只需简单输入： <br>If you want to use a (flat) filesystem directory as a repository, simply type:</p>
     <div class="example">
      <a name="flatDirMulti"></a>
      <p class="title"><b>示例 50.33. 平面仓库解析器 - Example&nbsp;50.33.&nbsp;Flat repository resolver</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    flatDir {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
    }
    flatDir {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib1'</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib2'</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>这将添加一些在一个或多个目录查找依赖的仓库。如果你只使用平面目录解析器，那么不需要设置依赖的所有属性。请参阅 <a class="xref" href="dependency_management.html#para:dependencies_with_empty_attributes">第 50.4.8 节，《可选属性》</a> <br>This adds repositories which look into one or more directories for finding dependencies. If you only work with flat directory resolvers you don't need to set all attributes of a dependency. See <a class="xref" href="dependency_management.html#para:dependencies_with_empty_attributes">Section&nbsp;50.4.8, “Optional attributes”</a></p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:ivy_repositories"></a>50.6.7. Ivy 仓库</h3>
        <h5 class="title"><a name="sec:ivy_repositories"></a>50.6.7.&nbsp;Ivy repositories</h5>
       </div>
      </div>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N1509B"></a>50.6.7.1.&nbsp;使用标准布局定义 Ivy 仓库</h4>
         <h6 class="title"><a name="N1509B"></a>50.6.7.1.&nbsp;Defining an Ivy repository with a standard layout</h6>
        </div>
       </div>
      </div>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例 50.34. Ivy 仓库 - Example&nbsp;50.34.&nbsp;Ivy repository</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N150A8"></a>50.6.7.2. 为 Ivy 仓库定义指定名称的布局</h4>
         <h6 class="title"><a name="N150A8"></a>50.6.7.2.&nbsp;Defining a named layout for an Ivy repository</h6>
        </div>
       </div>
      </div>
      <p> 通过使用指定名称的布局，可以指定仓库遵循 Ivy 或 Maven 的默认布局。 <br>You can specify that your repository conforms to the Ivy or Maven default layout by using a named layout.</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例50.35.&nbsp;使用指定名称的布局的 Ivy 仓库 - Example&nbsp;50.35.&nbsp;Ivy repository with named layout</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"maven"</span>
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
      <p> 布局名称的有效值为 <code class="literal">'gradle'</code> （默认值）,<code class="literal">'maven'</code> 和 <code class="literal">'ivy'</code>。有关这些指定的布局，请参阅 <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout(java.lang.String, groovy.lang.Closure)" target="_top"><code class="classname">IvyArtifactRepository.layout()</code></a>。 <br>Valid named layout values are <code class="literal">'gradle'</code> (the default), <code class="literal">'maven'</code> and <code class="literal">'ivy'</code>. See <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout(java.lang.String, groovy.lang.Closure)" target="_top"><code class="classname">IvyArtifactRepository.layout()</code></a> for details of these named layouts.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N150C7"></a>50.6.7.3. 为 Ivy 仓库定义定制模式布局</h4>
         <h6 class="title"><a name="N150C7"></a>50.6.7.3.&nbsp;Defining custom pattern layout for an Ivy repository</h6>
        </div>
       </div>
      </div>
      <p>要定义非标准布局的 Ivy 仓库，你可以为这个仓库定义一个“模式”布局： <br>To define an Ivy repository with a non-standard layout, you can define a 'pattern' layout for the repository:</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例 50.36. 使用模式而已的 Ivy 仓库 - Example&nbsp;50.36.&nbsp;Ivy repository with pattern layout</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"[module]/[revision]/[type]/[artifact].[ext]"</span>
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
      <p>要定义一个从不同的位置获取 Ivy 文件和工件的 Ivy 仓库，你可以定义用于查找 Ivy 文件和工件的单独模式： <br>To define an Ivy repository which fetches Ivy files and artifacts from different locations, you can define separate patterns to use to locate the Ivy files and artifacts:</p>
      <p> 一个仓库指定的每个 <code class="literal">artifact</code> 或 <code class="literal">ivy</code> 都添加了一个要使用的 <span class="emphasis"><em>其他</em></span> 模式。这些模式按照它们被定义的顺序使用。 <br>Each <code class="literal">artifact</code> or <code class="literal">ivy</code> specified for a repository adds an <span class="emphasis"><em>additional</em></span> pattern to use. The patterns are used in the order that they are defined.</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例50.37.&nbsp;使用多个定制模式的 Ivy 仓库 - Example&nbsp;50.37.&nbsp;Ivy repository with multiple custom patterns</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            ivy <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"ivy-files/[organisation]/[module]/[revision]/ivy.xml"</span>
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
      <p>作为可选的功能，一个使用模式布局的仓库可以让它的“组织”部分使用是Maven 风格，以斜杠替换点作为分隔符。例如，组织 <code class="literal">my.company</code> 将表示为 <code class="literal">my/company</code>。 <br>Optionally, a repository with pattern layout can have its 'organisation' part laid out in Maven style, with forward slashes replacing dots as separators. For example, the organisation <code class="literal">my.company</code> would then be represented as <code class="literal">my/company</code>.</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例50.38.&nbsp;使用 Maven 兼容布局的 Ivy 仓库 - Example&nbsp;50.38.&nbsp;Ivy repository with Maven compatible layout</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"pattern"</span>, {
            artifact <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            m2compatible = true
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="N150FF"></a>50.6.7.4. 访问受密码保护的 Ivy 仓库</h4>
         <h6 class="title"><a name="N150FF"></a>50.6.7.4.&nbsp;Accessing password protected Ivy repositories</h6>
        </div>
       </div>
      </div>
      <p>要访问一个使用基本认证的 Ivy 仓库，请在定义该仓库时指定要使用的用户名和密码： <br>To access an Ivy repository which uses basic authentication, you specify the username and password to use when you define the repository:</p>
      <div class="example">
       <a name="ivyRepository"></a>
       <p class="title"><b>示例 50.39. Ivy 仓库 - Example&nbsp;50.39.&nbsp;Ivy repository</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'http://repo.mycompany.com'</span>
        credentials {
            username <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'user'</span>
            password <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'password'</span>
        }
    }
}</pre>
       </div>
      </div>
      <br class="example-break">
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="N1510E"></a>50.6.8.&nbsp;使用仓库</h3>
        <h5 class="title"><a name="N1510E"></a>50.6.8.&nbsp;Working with repositories</h5>
       </div>
      </div>
     </div>
     <p>要访问一个仓库：<br>To access a repository:</p>
     <div class="example">
      <a name="defineRepository"></a>
      <p class="title"><b>示例 50.40. 访问一个仓库： - Example&nbsp;50.40.&nbsp;Accessing a repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">println repositories.localRepository.name
    println repositories[<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'localRepository'</span>].name</pre>
      </div>
     </div>
     <br class="example-break">
     <p>要配置一个仓库：<br>To configure a repository:</p>
     <div class="example">
      <a name="defineRepository"></a>
      <p class="title"><b>示例 50.41. 仓库配置 - Example&nbsp;50.41.&nbsp;Configuration of a repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    flatDir {
        name <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'localRepository'</span>
    }
}
repositories {
    localRepository {
        dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
    }
}
repositories.localRepository {
    dirs <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'lib'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:more_about_ivy_resolvers"></a>50.6.9. 更多关于 Ivy 解析器的信息</h3>
        <h5 class="title"><a name="sub:more_about_ivy_resolvers"></a>50.6.9.&nbsp;More about Ivy resolvers</h5>
       </div>
      </div>
     </div>
     <p>Gradle 得益于其幕后的 Ivy，它在仓库方面非常灵活。 <br>Gradle, thanks to Ivy under its hood, is extremely flexible regarding repositories:</p>
     <div class="itemizedlist">
      <ul class="itemizedlist">
       <li class="listitem"><p>与仓库通信的协议有许多选择（比如文件系统，http，ssh，sftp……） </p><p>There are many options for the protocol to communicate with the repository (e.g. filesystem, http, ssh, sftp ...) </p></li>
       <li class="listitem"><p>sftp 协议当前仅支持基于用户名/密码的认证。 </p><p>The protocol sftp currently only supports username/password-based authentication. </p></li>
       <li class="listitem"><p>每个仓库都可以有其自己的布局。 </p><p>Each repository can have its own layout. </p></li>
      </ul>
     </div>
     <p>比如说，你声明了一个对 <code class="literal">junit:jun:3.8.2</code> 库的依赖。现在 Gradle 是怎么在仓库中找到它的呢？依赖信息是必须映射到路径上的。相比于固定路径的 Maven，Gradle 可以定义一个模式，这个模式定义了路径的表示形式。这里有一些例子：<sup>[<a href="#ftn.N1513E" name="N1513E" class="footnote">16</a>]</sup> <br>Let's say, you declare a dependency on the <code class="literal">junit:junit:3.8.2</code> library. Now how does Gradle find it in the repositories? Somehow the dependency information has to be mapped to a path. In contrast to Maven, where this path is fixed, with Gradle you can define a pattern that defines what the path will look like. Here are some examples: <sup>[<a href="#ftn.N1513E" name="N1513E" class="footnote">16</a>]</sup></p>
     <pre class="programlisting">// Maven2 layout (if a repository is marked as Maven2 compatible, the organization (group) is split into subfolders according to the dots.)
someroot/[organisation]/[module]/[revision]/[module]-[revision].[ext]

// Typical layout for an Ivy repository (the organization is not split into subfolder)
someroot/[organisation]/[module]/[revision]/[type]s/[artifact].[ext]

// Simple layout (the organization is not used, no nested folders.)
someroot/[artifact]-[revision].[ext]</pre>
     <p>要添加任何一种仓库（你可以很方便地编写自己的仓库），你可以这样做： <br>To add any kind of repository (you can pretty easy write your own ones) you can do:</p>
     <div class="example">
      <a name="fileSystemResolver"></a>
      <p class="title"><b>示例 50.42. 定制仓库的定义 - Example&nbsp;50.42.&nbsp;Definition of a custom repository</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">repositories {
    ivy {
        ivyPattern <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$projectDir/repo/[organisation]/[module]-ivy-[revision].xml"</span>
        artifactPattern <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"$projectDir/repo/[organisation]/[module]-[revision](-[classifier]).[ext]"</span>
    }
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>其中由 Ivy（也因此由 Gradle）提供的解析器，它的概述可以在<a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" target="_top">这里</a>找到。通过 Gradle，你只是不通过 XML 进行配置，而是通过它们的 API。 <br>An overview of which Resolvers are offered by Ivy and thus also by Gradle can be found <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/settings/resolvers.html" target="_top">here</a>. With Gradle you just don't configure them via XML but directly via their API.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependency_resolution"></a>50.7. 依赖解析的工作原理</h2>
       <h4 class="title"><a name="sec:dependency_resolution"></a>50.7.&nbsp;How dependency resolution works</h4>
      </div>
     </div>
    </div>
    <p>Gradle 将获取你的依赖声明和仓库定义，并尝试通过称为 <span class="emphasis"><em>依赖解析</em></span>的过程来下载所有依赖。以下是该过程如何工作的简要概述。 <br>Gradle takes your dependency declarations and repository definitions and attempts to download all of your dependencies by a process called <span class="emphasis"><em>dependency resolution</em></span>. Below is a brief outline of how this process works.</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p> 给定一个所需要的依赖，Gradle 首先尝试解析该依赖的<span class="emphasis"><em>模块</em></span>。每个仓库都按顺序进行检查，首先搜索指示该模块存在的 <span class="emphasis"><em>模块描述符</em></span> 文件（POM 或 Ivy 文件）。如果没找到模块描述符，Gradle 将搜索表示模块存在于仓库中的主要 <span class="emphasis"><em>模块工件</em></span> 文件。 </p>
       <div class="itemizedlist">
        <ul class="itemizedlist">
         <li class="listitem"><p>如果依赖被声明为一个动态版本（如 <code class="literal">1.+</code>），Gradle 将会把它解析为仓库中最新的静态版本（如 <code class="literal">1.2</code>）。对于 Maven 存储库，它是通过 <code class="literal">maven-metadata.xml</code> 文件来实现的；而对于 Ivy 存储库，则是通过目录列表来实现。 </p></li>
         <li class="listitem"><p>如果模块描述符是一个有父 POM 声明的 POM 文件，Gradle 将以递归方式尝试解析该 POM 文件的每个父模块。 </p></li>
        </ul>
       </div><p> Given a required dependency, Gradle first attempts to resolve the <span class="emphasis"><em>module</em></span> for that dependency. Each repository is inspected in order, searching first for a <span class="emphasis"><em>module descriptor</em></span> file (POM or Ivy file) that indicates the presence of that module. If no module descriptor is found, Gradle will search for the presence of the primary <span class="emphasis"><em>module artifact</em></span> file indicating that the module exists in the repository. </p> 
       <div class="itemizedlist"> 
        <ul class="itemizedlist"> 
         <li class="listitem"><p>If the dependency is declared as a dynamic version (like <code class="literal">1.+</code>), Gradle will resolve this to the newest available static version (like <code class="literal">1.2</code>) in the repository. For Maven repositories, this is done using the <code class="literal">maven-metadata.xml</code> file, while for Ivy repositories this is done by directory listing. </p></li> 
         <li class="listitem"><p>If the module descriptor is a POM file that has a parent POM declared, Gradle will recursively attempt to resolve each of the parent modules for the POM. </p></li> 
        </ul> 
       </div></li>
      <li class="listitem"><p>在对每个仓库进行模块检查后，Gradle 会选择使用“最好的”那个仓库。它使用以下标准完成的： </p>
       <div class="itemizedlist">
        <ul class="itemizedlist">
         <li class="listitem">对于动态版本，“较高”的静态版本优先于“较低”的版本。</li>
         <li class="listitem">由模块描述符文件（Ivy 或 POM 文件）声明的模块优先于只有一个工件文件的模块。</li>
         <li class="listitem">先声明的仓库的模块优先于后面的仓库的模块。</li>
        </ul>
       </div><p> </p><p>当依赖声明为静态版本，并且在仓库中找到模块描述符文件时，将不再需要继续搜索后面的仓库，这个过程的其余部分是短路的。 </p><p>Once each repository has been inspected for the module, Gradle will choose the 'best' one to use. This is done using the following criteria: </p> 
       <div class="itemizedlist"> 
        <ul class="itemizedlist"> 
         <li class="listitem">For a dynamic version, a 'higher' static version is preferred over a 'lower' version.</li> 
         <li class="listitem">Modules declared by a module descriptor file (Ivy or POM file) are preferred over modules that have an artifact file only.</li> 
         <li class="listitem">Modules from earlier repositories are preferred over modules in later repositories.</li> 
        </ul> 
       </div><p> </p><p>When the dependency is declared by a static version and a module descriptor file is found in a repository, there is no need to continue searching later repositories and the remainder of the process is short-circuited. </p></li>
      <li class="listitem"><p>然后将从上面的过程所选择的 <span class="emphasis"><em>同一个仓库</em></span> 中请求这个模块的所有工件。 </p><p>All of the artifacts for the module are then requested from the <span class="emphasis"><em>same repository</em></span> that was chosen in the process above. </p></li>
     </ul>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="N15192"></a>50.8. 微调依赖解析过程</h2>
       <h4 class="title"><a name="N15192"></a>50.8.&nbsp;Fine-tuning the dependency resolution process</h4>
      </div>
     </div>
    </div>
    <p>在大多数情况下，Gradle 默认的依赖管理会解析你构建中所需要的依赖。但是，在某些情况下，可能需要轻微调整依赖解析，以确保你的构建能精确得到正确的依赖。 <br>In most cases, Gradle's default dependency management will resolve the dependencies that you want in your build. In some cases, however, it can be necessary to tweak dependency resolution to ensure that your build receives exactly the right dependencies.</p>
    <p>有许多种方式可以影响到 Gradle 的依赖解析。<br>There are a number of ways that you can influence how Gradle resolves dependencies.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:forcing_modules"></a>50.8.1.&nbsp;强制使用特定模块版本</h3>
        <h5 class="title"><a name="sec:forcing_modules"></a>50.8.1.&nbsp;Forcing a particular module version</h5>
       </div>
      </div>
     </div>
     <p>强制使用一个模块版本，是指示 Gradle 对于给定的依赖（传递或非传递），始终使用一个特定的版本，并覆盖在发布的模块描述符中所指定的任何版本。当处理版本冲突时，这非常有用——有关详细信息，请参阅 <a class="xref" href="dependency_management.html#sub:version_conflicts">第 50.2.3 节，《解决版本冲突》</a>。 <br>Forcing a module version tells Gradle to always use a specific version for given dependency (transitive or not), overriding any version specified in a published module descriptor. This can be very useful when tackling version conflicts - for more information see <a class="xref" href="dependency_management.html#sub:version_conflicts">Section&nbsp;50.2.3, “Resolve version conflicts”</a>.</p>
     <p> 强制版本也可用于处理传递依赖的恶意元数据。如果传递依赖的元数据质量有问题，导致依赖解析时出现问题，那么可以强制 Gradle 使用这个依赖较新的修复版本。有关示例，请参见 <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>。注意，“依赖解析规则”（见下文）提供了一种更强大的机制来取代已损坏的模块依赖。请参阅 <a class="xref" href="dependency_management.html#sec:blacklisting_version">第 50.8.2.3 节，《将特定版本列入黑名单并替换》</a>。 <br>Force versions can also be used to deal with rogue metadata of transitive dependencies. If a transitive dependency has poor quality metadata that leads to problems at dependency resolution time, you can force Gradle to use a newer, fixed version of this dependency. For an example, see <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>. Note that 'dependency resolve rules' (outlined below) provide a more powerful mechanism for replacing a broken module dependency. See <a class="xref" href="dependency_management.html#sec:blacklisting_version">Section&nbsp;50.8.2.3, “Blacklisting a particular version with a replacement”</a>.</p>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:dependency_resolve_rules"></a>50.8.2. 使用依赖解析规则</h3>
        <h5 class="title"><a name="sec:dependency_resolve_rules"></a>50.8.2.&nbsp;Using dependency resolve rules</h5>
       </div>
      </div>
     </div>
     <p>一个依赖解析规则针对每个已解析的依赖执行，并提供了一个功能强大的 api，用于在该依赖解析之前处理所请求的依赖。这个功能目前还是<a class="link" href="feature_lifecycle.html">实验性</a>功能，但当前提供了对一个所请求的依赖更改它的组，名称及版本的功能，从而允许在解析期间将一个依赖替换为一个完全不同的模块。 <br>A dependency resolve rule is executed for each resolved dependency, and offers a powerful api for manipulating a requested dependency prior to that dependency being resolved. This feature is <a class="link" href="feature_lifecycle.html">incubating</a>, but currently offers the ability to change the group, name and/or version of a requested dependency, allowing a dependency to be substituted with a completely different module during resolution.</p>
     <p> 依赖解析规则提供了一种非常强大的方法来控制依赖解析过程，并且可以用于实现依赖管理中的所有高级模式。下面是其中一些模式的概述。有关更多信息和代码示例，请参阅 <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>。 <br>Dependency resolve rules provide a very powerful way to control the dependency resolution process, and can be used to implement all sorts of advanced patterns in dependency management. Some of these patterns are outlined below. For more information and code samples see <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:releasable_unit"></a>50.8.2.1.&nbsp;模型化可发布单元</h4>
         <h6 class="title"><a name="sec:releasable_unit"></a>50.8.2.1.&nbsp;Modelling releaseable units</h6>
        </div>
       </div>
      </div>
      <p>通常一个组织会发布一组同一个版本的库；这些库一起构建，测试和发布。这些库形成了一个“可发布单元”，被设计并打算作为一个整体使用。而使用来自不同的可发布单元的库，也不会有意义。 <br>Often an organisation publishes a set of libraries with a single version; where the libraries are built, tested and published together. These libraries form a 'releasable unit', designed and intended to be used as a whole. It does not make sense to use libraries from different releasable units together.</p>
      <p> 但传递依赖的解析会很容易破坏这种协议。举个例子： <br>But it is easy for transitive dependency resolution to violate this contract. For example:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem"><code class="literal">module-a</code> 依赖于 <code class="literal">releasable-unit:part-one:1.0</code> <br><code class="literal">module-a</code> depends on <code class="literal">releasable-unit:part-one:1.0</code></li>
        <li class="listitem"><code class="literal">module-a</code> 依赖于 <code class="literal">releasable-unit:part-one:1.0</code><br><code class="literal">module-b</code> depends on <code class="literal">releasable-unit:part-two:1.1</code></li>
       </ul>
      </div>
      <p> 一个同时依赖于 <code class="literal">module-a</code> 和 <code class="literal">module-b</code> 的构建，将在可发布单元内获得这个库的不同版本。 <br>A build depending on both <code class="literal">module-a</code> and <code class="literal">module-b</code> will obtain different versions of libraries within the releasable unit.</p>
      <p> 依赖解析规则使你能够在构建中强制指定可发布单元。设想一下，一个可发布单元，由有 “org.gradle” 组的所有库定义。我们可以强制所有这些库使用一致的版本： <br>Dependency resolve rules give you the power to enforce releasable units in your build. Imagine a releasable unit defined by all libraries that have 'org.gradle' group. We can force all of these libraries to use a consistent version:</p>
      <div class="example">
       <a name="releasable-unit"></a>
       <p class="title"><b>示例 50.43. 强制一个组的所有库使用一致的版本 - Example&nbsp;50.43.&nbsp;Forcing consistent version for a group of libraries</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.gradle'</span>) {
            details.useVersion <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.4'</span>
        }
    }
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:custom_versioning_scheme"></a>50.8.2.2.&nbsp;实现自定义版本方案</h4>
         <h6 class="title"><a name="sec:custom_versioning_scheme"></a>50.8.2.2.&nbsp;Implement a custom versioning scheme</h6>
        </div>
       </div>
      </div>
      <p> 在某些企业环境中，可以在 Gradle 构建中声明的模块版本列表，是在外部进行维护和审计的。依赖解析规则提供了这种模式的整洁实现： <br>In some corporate environments, the list of module versions that can be declared in Gradle builds is maintained and audited externally. Dependency resolve rules provide a neat implementation of this pattern:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">在构建脚本中，开发人员使用模块组和名称声明依赖，但版本使用占位符，例如：“<code class="literal">default</code>”。<br>In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: '<code class="literal">default</code>'.</li>
        <li class="listitem">这个“default”版本通过依赖解析规则被解析为一个特定的版本，该规则将在一个已核准模块的公司目录中查找该版本。<br>The 'default' version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.</li>
       </ul>
      </div>
      <p> 该规则的实现可以灵活地封装在一个公司插件中，并在组织内的所有构建中共享。 <br>This rule implementation can be neatly encapsulated in a corporate plugin, and shared across all builds within the organisation.</p>
      <div class="example">
       <a name="custom-versioning-scheme"></a>
       <p class="title"><b>示例 50.44. 使用自定义的版本方案 - Example&nbsp;50.44.&nbsp;Using a custom versioning scheme</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'default'</span>) {
            def version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
            details.useVersion version
        }
    }
}

def findDefaultVersionInCatalog(String group, String name) {
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//some custom logic that resolves the default version into a specific version</span>
    <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"1.0"</span>
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:blacklisting_version"></a>50.8.2.3. 通过替换把特定版本列入黑名单</h4>
         <h6 class="title"><a name="sec:blacklisting_version"></a>50.8.2.3.&nbsp;Blacklisting a particular version with a replacement</h6>
        </div>
       </div>
      </div>
      <p> 依赖解析规则提供了一种机制，用于将特定版本的依赖列入黑名单并提供替换版本。 如果某个依赖版本已损坏且不应使用，那么这就会很有用，因为依赖解析规则可以将这个版本替换为已知的好的版本。有关损坏模块的例子有，在一个库上所声明的依赖在任何公共仓库中都找不到。但是为什么不能使用特定的模块版本，而更希望另一个不同的版本，还有许多其他原因。 <br>Dependency resolve rules provide a mechanism for blacklisting a particular version of a dependency and providing a replacement version. This can be useful if a certain dependency version is broken and should not be used, where a dependency resolve rule causes this version to be replaced with a known good version. One example of a broken module is one that declares a dependency on a library that cannot be found in any of the public repositories, but there are many other reasons why a particular module version is unwanted and a different version is preferred.</p>
      <p> 在下面的示例中，假设版本 <code class="literal">1.2.1</code> 包含了重要的修复，并且应该始终优先于 <code class="literal">1.2</code> 使用。提供的规则将仅强制执行如下操作：在任何时间，遇到了版本 <code class="literal">1.2</code> 时，都把它替换为 <code class="literal">1.2.1</code>。请注意，这与上面描述的强制版本有所区别，因为这个模块的其他版本都不受影响。这意味着，如果版本 <code class="literal">1.3</code> 也由于依赖传递被获取到，那么"最新的"冲突解决策略还是会选择这个新的版本。 <br>In example below, imagine that version <code class="literal">1.2.1</code> contains important fixes and should always be used in preference to <code class="literal">1.2</code>. The rule provided will enforce just this: any time version <code class="literal">1.2</code> is encountered it will be replaced with <code class="literal">1.2.1</code>. Note that this is different from a forced version as described above, in that any other versions of this module would not be affected. This means that the 'newest' conflict resolution strategy would still select version <code class="literal">1.3</code> if this version was also pulled transitively.</p>
      <div class="example">
       <a name="blacklisting_version"></a>
       <p class="title"><b>示例 50.45. 通过替换把版本列入黑名单 - Example&nbsp;50.45.&nbsp;Blacklisting a version with a replacement</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'org.software'</span> &amp;&amp; details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'some-library'</span> &amp;&amp; details.requested.version == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.2'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer different version which contains some necessary fixes</span>
            details.useVersion <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'1.2.1'</span>
        }
    }
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sec:module_substitution"></a>50.8.2.4. 使用兼容模块替换依赖模块</h4>
         <h6 class="title"><a name="sec:module_substitution"></a>50.8.2.4.&nbsp;Substituting a dependency module with a compatible replacement</h6>
        </div>
       </div>
      </div>
      <p>有时候，可以用一个完全不同的模块来替换所请求的模块依赖。示例包括，使用 “<code class="literal">groovy</code>” 代替 “<code class="literal">groovy-all</code>”，或使用 “<code class="literal">log4j-over-slf4j</code>” 代替 “<code class="literal">log4j</code>”。从 Gradle 1.5 起，你可以使用依赖解析规则来进行这些替换： <br>At times a completely different module can serve as a replacement for a requested module dependency. Examples include using '<code class="literal">groovy</code>' in place of '<code class="literal">groovy-all</code>', or using '<code class="literal">log4j-over-slf4j</code>' instead of '<code class="literal">log4j</code>'. Starting with Gradle 1.5 you can make these substitutions using dependency resolve rules:</p>
      <div class="example">
       <a name="module_substitution"></a>
       <p class="title"><b>示例 50.46. 在解析中更改依赖组及名称 - Example&nbsp;50.46.&nbsp;Changing dependency group and/or name at the resolution</b></p>
       <div class="example-contents">
        <p><code class="filename">build.gradle</code></p>
        <pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy-all'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer 'groovy' over 'groovy-all':</span>
            details.useTarget group: details.requested.group, name: <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'groovy'</span>, version: details.requested.version
        }
        <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.requested.name == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'log4j'</span>) {
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">//prefer 'log4j-over-slf4j' over 'log4j', with fixed version:</span>
            details.useTarget <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"org.slf4j:log4j-over-slf4j:1.7.5"</span>
        }
    }
}</pre>
       </div>
      </div>
      <p><br class="example-break"> </p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="ivy_dynamic_resolve_mode"></a>50.8.3.&nbsp;启用 Ivy 动态解析模式</h3>
        <h5 class="title"><a name="ivy_dynamic_resolve_mode"></a>50.8.3.&nbsp;Enabling Ivy dynamic resolve mode</h5>
       </div>
      </div>
     </div>
     <p> Gradle 的 Ivy 仓库实现支持相当于 Ivy 的动态解析模式。通常情况下，Gradle 将 <code class="literal">rev</code> 属性用于 <code class="filename">ivy.xml</code> 文件中包含的每个依赖定义。在动态解析模式下，对于一个给定的依赖定义，Gradle 对 <code class="literal">revConstraint</code> 属性的使用优先于 <code class="literal">rev</code> 属性。如果 <code class="literal">revConstraint</code> 属性不存在，则使用 <code class="literal">rev</code> 属性。 <br>Gradle's Ivy repository implementations support the equivalent to Ivy's dynamic resolve mode. Normally, Gradle will use the <code class="literal">rev</code> attribute for each dependency definition included in an <code class="filename">ivy.xml</code> file. In dynamic resolve mode, Gradle will instead prefer the <code class="literal">revConstraint</code> attribute over the <code class="literal">rev</code> attribute for a given dependency definition. If the <code class="literal">revConstraint</code> attribute is not present, the <code class="literal">rev</code> attribute is used instead.</p>
     <p>要启用动态解析模式，需要在仓库定义上设置相应的选项，示例如下。注意，动态解析方式只可用于 Gradle 的 Ivy 仓库，不能用于 Maven 仓库或自定义的 Ivy <code class="classname">DependencyResolver</code> 实现。<br>To enable dynamic resolve mode, you need to set the appropriate option on the repository definition. A couple of examples are shown below. Note that dynamic resolve mode is only available for Gradle's Ivy repositories. It is not available for Maven repositories, or custom Ivy <code class="classname">DependencyResolver</code> implementations.</p>
     <div class="example">
      <a name="dynamicResolveMode"></a>
      <p class="title"><b>示例 50.47.&nbsp;启用动态解析模式 - Example&nbsp;50.47.&nbsp;Enabling dynamic resolve mode</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting"><span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Can enable dynamic resolve mode when you define the repository</span>
repositories {
    ivy {
        url <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"http://repo.mycompany.com/repo"</span>
        resolve.dynamicMode = true
    }
}

<span xmlns:xslthl="http://xslthl.sf.net" class="hl-comment">// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories</span>
repositories.withType(IvyArtifactRepository) {
    resolve.dynamicMode = true
}</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="component_metadata_rules"></a>50.8.4. 组件元数据规则</h3>
        <h5 class="title"><a name="component_metadata_rules"></a>50.8.4.&nbsp;Component metadata rules</h5>
       </div>
      </div>
     </div>
     <p>每个模块（也称为<span class="emphasis"><em>组件</em></span>），都有与其相关的元数据，比如说组、名称、版本、依赖，等等。这些元数据通常来源于模块的描述符。元数据规则能够在构建脚本中处理模块元数据的某些部分。它们在模块的描述符下载之后，但在所有候选版本之间选择它之前生效。这使得元数据规则成为自定义依赖解析方案的另一种手段。 <br>Each module (also called <span class="emphasis"><em>component</em></span>) has metadata associated with it, such as its group, name, version, dependencies, and so on. This metadata typically originates in the module's descriptor. Metadata rules allow certain parts of a module's metadata to be manipulated from within the build script. They take effect after a module's descriptor has been downloaded, but before it has been selected among all candidate versions. This makes metadata rules another instrument for customizing dependency resolution.</p>
     <p> Gradle 理解的其中一个模块元数据是模块的 <span class="emphasis"><em>状态方案</em></span>。 这个概念也可以从 Ivy 中了解到，对随时间推移模块的不同成熟度级别进行建模。默认的状态方案，按从最低到最高的成熟度排序，分别为 <code class="literal">integration</code>，<code class="literal">milestone</code> 和 <code class="literal">release</code>。 除状态方案外，模块还有一个（当前）<span class="emphasis"><em>状态</em></span>，它必须是状态方案中的值之一。如果没有在（Ivy）描述符中指定， Ivy 模块和 Maven 快照模块的状态默认是 <code class="literal">integration</code>，而不是快照的 Maven 模块则默认为 <code class="literal">release</code>。 <br>One piece of module metadata that Gradle understands is a module's <span class="emphasis"><em>status scheme</em></span>. This concept, also known from Ivy, models the different levels of maturity that a module transitions through over time. The default status scheme, ordered from least to most mature status, is <code class="literal">integration</code>, <code class="literal">milestone</code>, <code class="literal">release</code>. Apart from a status scheme, a module also has a (current) <span class="emphasis"><em>status</em></span>, which must be one of the values in its status scheme. If not specified in the (Ivy) descriptor, the status defaults to <code class="literal">integration</code> for Ivy modules and Maven snapshot modules, and <code class="literal">release</code> for Maven modules that aren't snapshots.</p>
     <p> 一个模块的状态及状态模式，会在解析 <code class="literal">latest</code> 版本选择器时考虑到。具体而言，<code class="literal">latest.someStatus</code> 会解析成有着 <code class="literal">someStatus</code> 或更成熟状态的最高模块版本。例如，如果其他地方存在默认的状态模式，那么 <code class="literal">latest.integration</code> 将选择最高的模块版本，而不考虑其状态（因为 <code class="literal">integration</code> 是成熟度最低的状态），而 <code class="literal">latest.release</code> 将选择 <code class="literal">release</code> 状态的最高模块版本。以下是在代码中的表现： <br>A module's status and status scheme are taken into consideration when a <code class="literal">latest</code> version selector is resolved. Specifically, <code class="literal">latest.someStatus</code> will resolve to the highest module version that has status <code class="literal">someStatus</code> or a more mature status. For example, with the default status scheme in place, <code class="literal">latest.integration</code> will select the highest module version regardless of its status (because <code class="literal">integration</code> is the least mature status), whereas <code class="literal">latest.release</code> will select the highest module version with status <code class="literal">release</code>. Here is what this looks like in code:</p>
     <div class="example">
      <a name="latestSelector"></a>
      <p class="title"><b>示例&nbsp;50.48，“最新的”版本选择器 - Example&nbsp;50.48.&nbsp;'Latest' version selector</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    config1 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:latest.integration"</span>
    config2 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"sea.fish:tuna:latest.release"</span>
}

task listFish &lt;&lt; {
    configurations.config1.each { println it.name }
    println()
    configurations.config2.each { println it.name}
}</pre>
       <p><strong class="userinput"><code>gradle -q listFish</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q listFish</code></strong></p>
       <pre class="screen">&gt; gradle -q listFish
tuna-1.5.jar

tuna-1.4.jar</pre>
      </div>
     </div>
     <br class="example-break">
     <p> 下一个示例基于模块的元数据规则中声明的自定义状态模式，来演示 <code class="literal">latest</code> 选择器： <br>The next example demonstrates <code class="literal">latest</code> selectors based on a custom status scheme declared in a module metadata rule:</p>
     <div class="example">
      <a name="customStatusScheme"></a>
      <p class="title"><b>示例 50.49. 自定义状态模式 - Example&nbsp;50.49.&nbsp;Custom status scheme</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">dependencies {
    config3 <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds:albatros:latest.silver"</span>
    components {
        eachComponent { ComponentMetadataDetails details -&gt;
            <span xmlns:xslthl="http://xslthl.sf.net" class="hl-keyword">if</span> (details.id.group == <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"air.birds"</span>) {
                details.statusScheme = [<span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"bronze"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"silver"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"gold"</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">"platinum"</span>]
            }
        }
    }
}

task listBirds &lt;&lt; {
    configurations.config3.each { println it.name }
}</pre>
       <p><strong class="userinput"><code>gradle -q listBirds</code></strong>的输出结果<br>Output of <strong class="userinput"><code>gradle -q listBirds</code></strong></p>
       <pre class="screen">&gt; gradle -q listBirds
albatros-2.0.jar</pre>
      </div>
     </div>
     <br class="example-break">
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:dependency_cache"></a>50.9. 依赖缓存</h2>
       <h4 class="title"><a name="sec:dependency_cache"></a>50.9.&nbsp;The dependency cache</h4>
      </div>
     </div>
    </div>
    <p>Gradle 包含了一种高度复杂的依赖缓存机制，它力求减少依赖解析中的远程请求数，同时努力保证依赖解析结果正确且可重现。 <br>Gradle contains a highly sophisticated dependency caching mechanism, which seeks to minimise the number of remote requests made in dependency resolution, while striving to guarantee that the results of dependency resolution are correct and reproducible.</p>
    <p> Gradle 依赖缓存由两种关键类型的存储组成： <br>The Gradle dependency cache consists of 2 key types of storage:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p>基于文件的下载工件存储，包括了像 jar 这样的二进制文件，以及像 POM 文件及 Ivy 文件这样的原始下载的元数据。下载的工件的存储路径包含了 SHA1 校验和，它意味着可以很容易地缓存两个名称相同但内容不同的工件。 </p><p>A file-based store of downloaded artifacts, including binaries like jars as well as raw downloaded meta-data like POM files and Ivy files. The storage path for a downloaded artifact includes the SHA1 checksum, meaning that 2 artifacts with the same name but different content can easily be cached. </p></li>
      <li class="listitem"><p>解析的模块元数据的二进制存储，包括解析动态版本、 模块描述符和工件的结果。</p><p>A binary store of resolved module meta-data, including the results of resolving dynamic versions, module descriptors, and artifacts.</p></li>
     </ul>
    </div>
    <p>从下载的工件的存储中分离出缓存的元数据，使我们能够对比缓存执行一些非常强大的操作，而如果使用一个透明的只有文件的缓存布局则会很困难。 <br>Separating the storage of downloaded artifacts from the cache metadata permits us to do some very powerful things with our cache that would be difficult with a transparent, file-only cache layout.</p>
    <p>Gradle 缓存不允许本地缓存隐藏问题以及创建神秘且难以调试的行为，这些行为是许多构建工具所面临的挑战。这一新行为通过带宽和存储的有效途径实现。在这个过程中，Gradle 支持可靠且可复制的企业构建。 <br>The Gradle cache does not allow the local cache to hide problems and creating mysterious and difficult to debug behavior that has been a challenge with many build tools. This new behavior is implemented in a bandwidth and storage efficient way. In doing so, Gradle enables reliable and reproducible enterprise builds.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:cache_features"></a>50.9.1. Gradle 依赖缓存的关键特点</h3>
        <h5 class="title"><a name="sec:cache_features"></a>50.9.1.&nbsp;Key features of the Gradle dependency cache</h5>
       </div>
      </div>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_metadata"></a>50.9.1.1. 单独的元数据缓存</h4>
         <h6 class="title"><a name="sub:cache_metadata"></a>50.9.1.1.&nbsp;Separate metadata cache</h6>
        </div>
       </div>
      </div>
      <p> Gradle 在元数据缓存中以二进制格式保留了依赖解析各方面的记录。存在元数据缓存的信息包括： <br>Gradle keeps a record of various aspects of dependency resolution in binary format in the metadata cache. The information stored in the metadata cache includes:</p>
      <div class="itemizedlist">
       <ul class="itemizedlist">
        <li class="listitem">把一个动态版本（如<code class="literal">1.+</code>）解析为一个具体版本（如<code class="literal">1.2</code>）的结果。<br>The result of resolving a dynamic version (e.g. <code class="literal">1.+</code>) to a concrete version (e.g. <code class="literal">1.2</code>).</li>
        <li class="listitem">特定模块解析后的模块元数据，包括模块工件和模块依赖。<br>The resolved module metadata for a particular module, including module artifacts and module dependencies.</li>
        <li class="listitem">特定工件解析后的工件元数据，包括指向已下载的工件文件的信息。<br>The resolved artifact metadata for a particular artifact, including a pointer to the downloaded artifact file.</li>
        <li class="listitem">在特定的仓库中<span class="emphasis"><em>缺少的</em></span>特定模块或工件，避免反复地尝试访问不存在的资源。 <br>The <span class="emphasis"><em>absence</em></span> of a particular module or artifact in a particular repository, eliminating repeated attempts to access a resource that does not exist.</li>
       </ul>
      </div>
      <p> 元数据缓存中的每个条目都包括了一条仓库记录，它提供了信息以及可用于缓存到期的时间戳。 <br>Every entry in the metadata cache includes a record of the repository that provided the information as well as a timestamp that can be used for cache expiry.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_repository_independence"></a>50.9.1.2.&nbsp;仓库缓存是独立的</h4>
         <h6 class="title"><a name="sub:cache_repository_independence"></a>50.9.1.2.&nbsp;Repository caches are independent</h6>
        </div>
       </div>
      </div>
      <p>如上文所述，每个仓库都有一个单独的元数据缓存。一个仓库由它的 URL、类型和布局来进行标识。如果一个模块或工件在之前从没有在 <span class="emphasis"><em>这个仓库</em></span>中解析过，那么 Gradle 将尝试针对这个仓库来解析这个模块。这将始终涉及仓库的远程查找，但是在许多情况下并不需要下载（请参阅下面的<a class="xref" href="dependency_management.html#sub:cache_artifact_reuse">第 50.9.1.3 节，《工件复用》</a>）。 <br>As described above, for each repository there is a separate metadata cache. A repository is identified by its URL, type and layout. If a module or artifact has not been previously resolved from <span class="emphasis"><em>this repository</em></span>, Gradle will attempt to resolve the module against the repository. This will always involve a remote lookup on the repository, however in many cases no download will be required (see<a class="xref" href="dependency_management.html#sub:cache_artifact_reuse">Section&nbsp;50.9.1.3, “Artifact reuse”</a>, below).</p>
      <p>如果所需的构件，在构建所指定的任何仓库中都不可用，无论本地缓存是否已经从其他的仓库中获取到这个构件，依赖解析都会失败。仓库独立能够使构建之间用一种先进的方法彼此隔离，以前从没有构建工具能够做到。这是一个关键的功能，使得能够在任何环境中创建可靠且可复制的构建。 <br>Dependency resolution will fail if the required artifacts are not available in any repository specified by the build, regardless whether the local cache has retrieved this artifact from a different repository. Repository independence allows builds to be isolated from each other in an advanced way that no build tool has done before. This is a key feature to create builds that are reliable and reproducible in any environment.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_artifact_reuse"></a>50.9.1.3. 工件复用</h4>
         <h6 class="title"><a name="sub:cache_artifact_reuse"></a>50.9.1.3.&nbsp;Artifact reuse</h6>
        </div>
       </div>
      </div>
      <p>在下载工件前，Gradle 试图通过下载与该工件关联的 sha 文件来确定所需工件的校验和。如果校验和可以获取得到，并且已经存在有相同 id 和校验和的工件，就不会再去下载为个工件。如果无法从远程服务器中获取校验和，则下载这个工件（并且如果它与现有工件相匹配就忽略掉）。 <br>Before downloading an artifact, Gradle tries to determine the checksum of the required artifact by downloading the sha file associated with that artifact. If the checksum can be retrieved, an artifact is not downloaded if an artifact already exists with the same id and checksum. If the checksum cannot be retrieved from the remote server, the artifact will be downloaded (and ignored if it matches an existing artifact).</p>
      <p>在考虑从其他仓库下载的工件时，Gradle 还将尝试复用在本地 Maven 仓库中找到的工件。如果某个候选工件已经通过 Maven 下载，并且它可以验证和远程服务器定义的校验和相匹配，Gradle 就会使用此工件。 <br>As well as considering artifacts downloaded from a different repository, Gradle will also attempt to reuse artifacts found in the local Maven Repository. If a candidate artifact has been downloaded by Maven, Gradle will use this artifact if it can be verified to match the checksum declared by the remote server.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_checksum_storage"></a>50.9.1.4.&nbsp;基于校验和的存储</h4>
         <h6 class="title"><a name="sub:cache_checksum_storage"></a>50.9.1.4.&nbsp;Checksum based storage</h6>
        </div>
       </div>
      </div>
      <p> 对于相同的工件标识，不同的仓库可能会提供不同的二进制工件。这种情况常见的是 Maven SNAPSHOT 工件，但是对于任何工件，都可以不更改其标识而重新发布。通过缓存基于 SHA1 校验和的工件，Gradle 能够维护同一工件的多个版本。意味着，当解析一个仓库时，Gradle 不会从其他仓库中覆盖已缓存的工件文件。它不需要一个单独的工件文件在每个仓库都存储就可以做到。 <br>It is possible for different repositories to provide a different binary artifact in response to the same artifact identifier. This is often the case with Maven SNAPSHOT artifacts, but can also be true for any artifact which is republished without changing it's identifier. By caching artifacts based on their SHA1 checksum, Gradle is able to maintain multiple versions of the same artifact. This means that when resolving against one repository Gradle will never overwrite the cached artifact file from a different repository. This is done without requiring a separate artifact file store per repository.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_locking"></a>50.9.1.5. 缓存锁</h4>
         <h6 class="title"><a name="sub:cache_locking"></a>50.9.1.5.&nbsp;Cache Locking</h6>
        </div>
       </div>
      </div>
      <p> Gradle 依赖缓存使用基于文件的锁，以确保可安全地由多个 Gradle 进程并行使用。每当正在读取或写入二进制元数据存储时，就会持有锁，但是会对诸如下载远程工件之类的慢操作时会释放锁。 <br>The Gradle dependency cache uses file-based locking to ensure that it can safely be used by multiple Gradle processes concurrently. The lock is held whenever the binary meta-data store is being read or written, but is released for slow operations such as downloading remote artifacts.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:cache_command_line_options"></a>50.9.2.&nbsp;覆盖缓存的命令行选项</h3>
        <h5 class="title"><a name="sec:cache_command_line_options"></a>50.9.2.&nbsp;Command line options to override caching</h5>
       </div>
      </div>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_offline"></a>50.9.2.1.&nbsp;离线</h4>
         <h6 class="title"><a name="sub:cache_offline"></a>50.9.2.1.&nbsp;Offline</h6>
        </div>
       </div>
      </div>
      <p><code class="literal">--offline</code> 命令行开关告诉 Gradle 始终使用缓存中的依赖模块，而不考虑是否要再检查。在使用离线模式运行时，Gradle 将不会尝试访问网络来执行依赖解析。如果所需的模块在依赖缓存中不存在，构建执行就会失败。 <br>The <code class="literal">--offline</code> command line switch tells Gradle to always use dependency modules from the cache, regardless if they are due to be checked again. When running with offline, Gradle will never attempt to access the network to perform dependency resolution. If required modules are not present in the dependency cache, build execution will fail.</p>
     </div>
     <div class="section">
      <div class="titlepage">
       <div>
        <div>
         <h4 class="title"><a name="sub:cache_refresh"></a>50.9.2.2.&nbsp;刷新</h4>
         <h6 class="title"><a name="sub:cache_refresh"></a>50.9.2.2.&nbsp;Refresh</h6>
        </div>
       </div>
      </div>
      <p>有时，Gradle 依赖缓存可能会与已配置仓库的实际状态不同步。也许一个仓库的最初配置有误，或者是没有正确发布“无更改”模块。要刷新依赖缓存中的所有依赖，请在命令行上使用 <code class="literal">--refresh-dependencies</code> 选项。 <br>At times, the Gradle Dependency Cache can be out of sync with the actual state of the configured repositories. Perhaps a repository was initially misconfigured, or perhaps a "non-changing" module was published incorrectly. To refresh all dependencies in the dependency cache, use the <code class="literal">--refresh-dependencies</code> option on the command line.</p>
      <p><code class="literal">--refresh-dependencies</code> 选项告诉 Gradle 忽略已解析的模块和工件的所有缓存条目。所有已配置的仓库都会执行新的解析，并重新计算动态版本，刷新模块及下载工件。但是，在可能的情况下，Gradle 会检查之前下载的工件是否有效，然后再下载。这是通过比较仓库中已发布的 SHA1 值和现在已下载好的工件的 SHA1 值来完成的。 <br>The <code class="literal">--refresh-dependencies</code> option tells Gradle to ignore all cached entries for resolved modules and artifacts. A fresh resolve will be performed against all configured repositories, with dynamic versions recalculated, modules refreshed, and artifacts downloaded. However, where possible Gradle will check if the previously downloaded artifacts are valid before downloading again. This is done by comparing published SHA1 values in the repository with the SHA1 values for existing downloaded artifacts.</p>
     </div>
    </div>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sec:controlling_caching"></a>50.9.3. 依赖缓存的微调控制</h3>
        <h5 class="title"><a name="sec:controlling_caching"></a>50.9.3.&nbsp;Fine-tuned control over dependency caching</h5>
       </div>
      </div>
     </div>
     <p>你可以在配置中使用 <code class="literal">ResolutionStrategy</code> 对缓存的某些方面进行微调。 <br>You can fine-tune certain aspects of caching using the <code class="literal">ResolutionStrategy</code> for a configuration.</p>
     <p>默认情况下，Gradle 缓存动态版本的时间为 24 小时。如果要更改 Gradle 对动态版本解析到的版本的缓存时间，请使用： <br>By default, Gradle caches dynamic versions for 24 hours. To change how long Gradle will cache the resolved version for a dynamic version, use:</p>
     <div class="example">
      <a name="dynamic-version-cache-control"></a>
      <p class="title"><b>示例 50.50. 动态版本缓存控制 - Example&nbsp;50.50.&nbsp;Dynamic version cache control</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">10</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'minutes'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>默认情况下， Gradle缓存变化模块的时间为 24 小时。如果要更改 Gradle 缓存变化模块的元数据和工件的时间，请使用： <br>By default, Gradle caches changing modules for 24 hours. To change how long Gradle will cache the meta-data and artifacts for a changing module, use:</p>
     <div class="example">
      <a name="changing-module-cache-control"></a>
      <p class="title"><b>示例 50.51. 变化模块缓存控制 - Example&nbsp;50.51.&nbsp;Changing module cache control</b></p>
      <div class="example-contents">
       <p><code class="filename">build.gradle</code></p>
       <pre class="programlisting">configurations.all {
    resolutionStrategy.cacheChangingModulesFor <span xmlns:xslthl="http://xslthl.sf.net" class="hl-number">4</span>, <span xmlns:xslthl="http://xslthl.sf.net" class="hl-string">'hours'</span>
}</pre>
      </div>
     </div>
     <br class="example-break">
     <p>更多详细信息请参阅 <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> 的 API 文档。 <br>For more details, take a look at the API documentation for<a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p>
    </div>
   </div>
   <div class="section">
    <div class="titlepage">
     <div>
      <div>
       <h2 class="title"><a name="sec:strategies_of_transitive_dependency_management"></a>50.10. 传递依赖管理的策略</h2>
       <h4 class="title"><a name="sec:strategies_of_transitive_dependency_management"></a>50.10.&nbsp;Strategies for transitive dependency management</h4>
      </div>
     </div>
    </div>
    <p>许多项目依赖于 <a class="ulink" href="http://repo1.maven.org/maven2" target="_top">Maven 中央仓库</a>，这不是没有问题的。 <br>Many projects rely on the <a class="ulink" href="http://repo1.maven.org/maven2" target="_top">Maven Central repository</a>. This is not without problems.</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p>Maven 中央仓库可能会下线，或者响应时间很长。 </p><p>The Maven Central repository can be down or has a very long response time. </p></li>
      <li class="listitem"><p>许多项目的 POM 文件会有错误的信息（比如，<code class="literal">commons-httpclient-3.0</code> 的 POM 文件声明了 JUnit 是运行时依赖）。 </p><p>The POM files of many projects have wrong information (as one example, the POM of <code class="literal">commons-httpclient-3.0</code> declares JUnit as a runtime dependency). </p></li>
      <li class="listitem"><p>对于许多项目而言，没有一组正确依赖（因 POM 格式的影响会多或少）。 </p><p>For many projects there is not one right set of dependencies (as more or less imposed by the POM format). </p></li>
     </ul>
    </div>
    <p>如果你的项目依赖于 Maven 中央仓库，你很可能需要额外的自定义仓库，因为： <br>If your project relies on the Maven Central repository you are likely to need an additional custom repository, because:</p>
    <div class="itemizedlist">
     <ul class="itemizedlist">
      <li class="listitem"><p>你可能需要还没有上传到 Maven 中央仓的依赖。 </p><p>You might need dependencies that are not uploaded to Maven Central yet. </p></li>
      <li class="listitem"><p>你希望正确地处理 Maven 中央仓 POM 文件中错误的元数据。 </p><p>You want to deal properly with wrong metadata in a Maven Central POM file. </p></li>
      <li class="listitem"><p>你不希望 Maven 中央仓库故障停机或者有时候响应时间太长时，想要构建你的项目的人直接受到影响。 </p><p>You don't want to expose people who want to build your project, to the downtimes or sometimes very long response times of Maven Central. </p></li>
     </ul>
    </div>
    <p>设置一个自定义的仓库并不算什么，<sup>[<a href="#ftn.N1537C" name="N1537C" class="footnote">17</a>]</sup> 但想让这个仓库保持最新的态可能就会很烦人。对于一个新的版本，总是要创建新的 XML 描述符和目录。你的自定义仓库是另一个基础结构元素，可能会宕机，并且需要进行更新。 要启用历史构建，你需要保留所有之前的库，并且需要备份。这是另一个间接层，你必须查找的另一个信息源。所有这些都不是大问题，但累加起来就有影响了。仓库管理器（如 Artifactory 或 Nexus ）把这些事情变得轻松些。但是，举个例子，开源项目通常没有主机用于这些产品。而通过一些新服务，这种状况也改了，比如 <a class="ulink" href="http://bintray.com" target="_top">Bintray</a> ，它可以让开发者使用自助服务仓库平台来托管和分发他们发布的二进制文件。通过 <a class="ulink" href="http://jcenter.bintray.com" target="_top">JCenter</a> 公共仓库，Bintray 还支持共享通过他们审核的工件，为所有常用的 OSS Java 工件提供一个单一的解析地址（请参阅 <a class="xref" href="dependency_management.html#sub:maven_jcenter">第 50.6.3 节，《Maven JCenter 仓库》</a>)。 <br>It is not a big deal to set-up a custom repository. <sup>[<a href="#ftn.N1537C" name="N1537C" class="footnote">17</a>]</sup> But it can be tedious, to keep it up to date. For a new version, you have always to create the new XML descriptor and the directories. And your custom repository is another infrastructure element which might have downtimes and needs to be updated. To enable historical builds, you need to keep all the past libraries and you need a backup. It is another layer of indirection. Another source of information you have to lookup. All this is not really a big deal but in its sum it has an impact. Repository Manager like Artifactory or Nexus make this easier. But for example open source projects don't usually have a host for those products. This is changing with new services like <a class="ulink" href="http://bintray.com" target="_top">Bintray</a> that let developers host and distribute their release binaries using a self-service repository platform. Bintray also supports sharing approved artifacts though the <a class="ulink" href="http://jcenter.bintray.com" target="_top">JCenter</a> public repository to provide a single resolution address for all popular OSS java artifacts (see <a class="xref" href="dependency_management.html#sub:maven_jcenter">Section&nbsp;50.6.3, “Maven JCenter repository”</a>).</p>
    <p>这也是为什么一些项目希望将他们的库存在其版本控制系统中的原因。这种做法 Gradle 完全支持。库可以存在没有任何 XML 模块描述符文件的平面目录中，但 Gradle 提供了完整的传递依赖管理。你可以使用客户端模块依赖来表达依赖关系，或者是使用工件依赖，以防第一级依赖没有传递依赖。人们可以从 svn 中检出这样的项目，并具有构建它所需的的一切。 <br>This is a reason why some projects prefer to store their libraries in their version control system. This approach is fully supported by Gradle. The libraries can be stored in a flat directory without any XML module descriptor files. Yet Gradle offers complete transitive dependency management. You can use either client module dependencies to express the dependency relations, or artifact dependencies in case a first level dependency has no transitive dependencies. People can check out such a project from svn and have everything necessary to build it.</p>
    <p>如果你正在使用像 Git 一样的分布式版本控制系统，由于人们会检出整个历史，那么你可能不希望使用版本控制系统来保存这些库。但即使是这样，Gradle 的灵活性也可以让你更轻松。例如，你可以使用不带 XML 描述符的共享平面目录，但是却能如上所述有完整的传递依赖管理。 <br>If you are working with a distributed version control system like Git you probably don't want to use the version control system to store libraries as people check out the whole history. But even here the flexibility of Gradle can make your life easier. For example you can use a shared flat directory without XML descriptors and yet you can have full transitive dependency management as described above.</p>
    <p>你也可以使用混合策略。如果你主要关注的是 POM 文件中的错误元数据以及维护自定义的 XML 描述符，<span class="emphasis"><em>客户端模块</em></span>提供了一种替代方案。但你还是可以将 Maven2 仓库和自定义仓库用作 <span class="emphasis"><em>只放 jar</em></span> 的仓库，并且仍然可以使用<span class="emphasis"><em>传递</em></span>依赖管理。或者，你也可以只为带有错误元数据的 POM 提供客户端模块，而对于 jar 和正确的 POM 依然使用远程仓库。 <br>You could also have a mixed strategy. If your main concern is bad metadata in the POM file and maintaining custom XML descriptors, <span class="emphasis"><em>Client Modules</em></span> offer an alternative. But you can of course still use Maven2 repo and your custom repository as a repository for <span class="emphasis"><em>jars only</em></span> and still enjoy <span class="emphasis"><em>transitive</em></span> dependency management. Or you can only provide client modules for POMs with bad metadata. For the jars and the correct POMs you still use the remote repository.</p>
    <div class="section">
     <div class="titlepage">
      <div>
       <div>
        <h3 class="title"><a name="sub:implicit_transitive_dependencies"></a>50.10.1. 隐式传递依赖</h3>
        <h5 class="title"><a name="sub:implicit_transitive_dependencies"></a>50.10.1.&nbsp;Implicit transitive dependencies</h5>
       </div>
      </div>
     </div>
     <p>还有一种处理传递依赖 <span class="emphasis"><em>不带</em></span> XML 描述符文件的方法。你可以用 Gradle 来做，但是我们不推荐。之所以提到它，是为了完整性以及与其他构建工具作比较。 <br>There is another way to deal with transitive dependencies <span class="emphasis"><em>without</em></span> XML descriptor files. You can do this with Gradle, but we don't recommend it. We mention it for the sake of completeness and comparison with other build tools.</p>
     <p>这个诀窍是只使用工件依赖，并在列表中对它们分组。使用这种方法，你要以某种方式来表达你的第一级依赖是什么，传递依赖又是什么（请参阅<a class="xref" href="dependency_management.html#para:notation_collections">第 50.4.8 节，《可选属性》</a>）。而缺点是，对于 Gradle 依赖管理而言，所有依赖都会被当作是第一级依赖。依赖报告不会显示你实际上的依赖关系图，并且 <code class="literal">compile</code> 任务会使用所有依赖，而不仅仅是第一级的。总之，比起使用客户端模块，你的构建可维护性和可靠性都很差，而不会有其他好处。 <br>The trick is to use only artifact dependencies and group them in lists. That way you have somehow expressed, what are your first level dependencies and what are transitive dependencies (see <a class="xref" href="dependency_management.html#para:notation_collections">Section&nbsp;50.4.8, “Optional attributes”</a>). But the draw-back is, that for the Gradle dependency management all dependencies are considered first level dependencies. The dependency reports don't show your real dependency graph and the <code class="literal">compile</code> task uses all dependencies, not just the first level dependencies. All in all, your build is less maintainable and reliable than it could be when using client modules. And you don't gain anything.</p>
    </div>
   </div>
   <div class="footnotes">
    <br>
    <hr align="left" width="100">
    <div class="footnote">
     <p><sup>[<a href="#N14D1D" name="ftn.N14D1D" class="para">14</a>] </sup>Gradle 支持部分多项目构建（参见<a class="xref" href="multi_project_builds.html">第 56 章，《<i>多项目构建</i>》</a>）。<br><sup>[<a href="#N14D1D" name="ftn.N14D1D" class="para">14</a>] </sup>Gradle supports partial multiproject builds (see <a class="xref" href="multi_project_builds.html">Chapter&nbsp;56, <i>Multi-project Builds</i></a>).</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N14D3B" name="ftn.N14D3B" class="para">15</a>] </sup> <a class="ulink" href="http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html" target="_top">http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html</a> </p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N1513E" name="ftn.N1513E" class="para">16</a>] </sup>在 <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/concept.html" target="_top">http://ant.apache.org/ivy/history/latest-milestone/concept.html</a>，你可以了解到更多有关 ivy 模式的内容。 <br><sup>[<a href="#N1513E" name="ftn.N1513E" class="para">16</a>] </sup>At <a class="ulink" href="http://ant.apache.org/ivy/history/latest-milestone/concept.html" target="_top">http://ant.apache.org/ivy/history/latest-milestone/concept.html</a> you can learn more about ivy patterns.</p>
    </div>
    <div class="footnote">
     <p><sup>[<a href="#N1537C" name="ftn.N1537C" class="para">17</a>] </sup>如果你想在 Maven 中央仓库宕机时保护你的项目，事情会变得更复杂些。你可能想要为此设置一个仓库代理。在企业环境中，这种情况相当普遍。而对于开源项目，看起来就有些小题大做了。 <br><sup>[<a href="#N1537C" name="ftn.N1537C" class="para">17</a>] </sup>If you want to shield your project from the downtimes of Maven Central things get more complicated. You probably want to set-up a repository proxy for this. In an enterprise environment this is rather common. For an open source project it looks like overkill.</p>
    </div>
   </div>
  </div>
  <div class="navfooter">
   <div>
    <div class="navbar">
     <a xmlns:xslthl="http://xslthl.sf.net" href="buildDashboard_plugin.html" title="第四十九章. 构建仪表盘插件">上一章</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="userguide.html" title="Gradle 用户指南">目录</a>
     <span>|</span>
     <a xmlns:xslthl="http://xslthl.sf.net" href="artifact_management.html" title="第五十一章. 发布工件">下一章</a>
    </div>
   </div>
  </div>
 </body>
</html>